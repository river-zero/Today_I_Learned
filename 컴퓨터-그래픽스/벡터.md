- [좌표계](#좌표계)
- [왼손 좌표계 vs 오른손 좌표계](#왼손-좌표계-vs-오른손-좌표계)
- [벡터(vector)](#벡터vector)
- [벡터의 길이와 단위벡터](#벡터의-길이와-단위벡터)
- [벡터의 내적](#벡터의-내적)
- [직교 투영(Orthogonal Projection)](#직교-투영orthogonal-projection)
- [벡터의 외적](#벡터의-외적)
- [2D 유사 외적](#2d-유사-외적)
- [부동소수점의 오류](#부동소수점의-오류)

# 좌표계
수학에서 맨날 쓰던 직교 좌표계의 대표적인 예가 데카르트 좌표계다. 축의 확장이 편리하다는 장점이 있다. 

# 왼손 좌표계 vs 오른손 좌표계
z축을 추가하면서 z의 방향에 대한 사항이 문제가 된다. 

|  왼손 좌표계  | 오른손 좌표계 |
| :-----------: | :-----------: |
|    DirectX    |    OpenGL     |
| Unreal, Unity | 3Ds Max, CAD  |

게임에서는 주로 왼손 좌표계를 사용한다. 

# 벡터(vector)
방향과 크기를 가진 양이다. 크기와 방향이 같다면 어디에 있든 같은 벡터이다. 기하학에서 벡터를 다룰 때는 어떤 좌표계를 기준으로 다루는지, 또 어떤 좌표계로 변환하는지가 중요하다. 

# 벡터의 길이와 단위벡터
벡터 v의 길이는 ∥v∥로 표기한다. 2차원과 3차원에서 크기 공식은 아래와 같다.

$$||\vec{v}|| = \sqrt{x_1^2 + y_1^2}$$

$$||\vec{v}|| = \sqrt{x_1^2 + y_1^2 + z_1^2}$$

단위벡터는 벡터의 길이가 1인 벡터다. 정규화는 벡터를 바로 단위벡터로 변환하는 것을 밀한다.

$$\hat{v} = \frac{\vec{v}}{||\vec{v}||}$$

# 벡터의 내적
두 벡터를 곱해서 스칼라 값을 만들어 내는 연산이다.

$$\vec{u} \cdot \vec{v} = x_1x_2 + y_1y_2 + z_1z_2$$

$$\vec{a} \cdot \vec{b} = x_ax_b + y_ay_b = |\vec{a}||\vec{b}|cos{\theta}$$

내적의 결과값에 따라서 다음과 같은 의미를 가진다.

- 결과값 = 0 : u, v는 직교이다.
- 결과값 > 0 : 사이의 각도는 예각이다.
- 결과값 < 0 : 사이의 각도는 둔각이다.

# 직교 투영(Orthogonal Projection)
정사영이다. 벡터 v를 단위 벡터 n이 있는 선 위로 투영시킨 결과가 벡터 p라고 하자.

$$\vec{p} = (\vec{v} \cdot \vec{n})\vec{n}$$

만약 n이 단위 벡터가 아닌 일반 벡터라면 공식은 아래와 같다.

$$\vec{p} = proj_{\vec{n}}(\vec{v}) = \frac{\vec{v} \cdot \vec{n}}{||\vec{n}||^2}\vec{n}$$

# 벡터의 외적
두 벡터의 외적의 결과는 벡터이다. 외적은 연산 순서가 매우 중요하다.

$$\vec{u} \times \vec{v} = (u_yv_z - u_zv_y, u_zv_x - u_xv_z, u_xv_y - u_yv_x)$$

$$\vec{u} \times \vec{v}= -\vec{v} \times \vec{u}$$

$$||\vec{a} \times \vec{b}|| = ||\vec{a}||||\vec{b}||sin{\theta}$$

u에서 v로 왼손을 감으면 이때의 엄지 손가락의 방향이 외적의 방향이다. 물론 왼손 좌표계냐 오른손 좌표계냐에 따라 다르다.

# 2D 유사 외적
2D에서의 외적 연산은 스칼라 값이 되므로 크게 의미가 없다. 하지만 해당 값을 사용해 벡터의 방향을 판단할 수 있다.

- 결과값 > 0 : u에서 반시계 방향에 v가 위치
- 결과값 < 0 : u에서 시계 방향에 v가 위치
- 결과값 = 0 : u와 v가 평행

# 부동소수점의 오류
컴퓨터에서 사용하는 부동소수점은 사실 그렇게 정밀하지 않다. 특히 거듭제곱이나 제곱근과 같은 계산을 반복하면 더욱 정밀도가 떨어진다.

```
#include <iostream>

int main() {
    float a, b, c;

    a = 1.345f;
    b = 1.123f;
    c = a + b;

    if (c == 2.468) {
        std::cout << "동일O" << std::endl;
    } else {
        std::cout << "동일X" << std::endl;
    }
}
```

결과값을 보면 당연히 1.345 + 1.123 = 2.468이라고 생각하지만 그렇지 않음을 알 수 있다.float과 double의 형변환 과정에서 소수점 오차가 발생한 것이다. 이를 해결하기 위해서는 입실론이라는 매우 작은 값을 만들어 허용범위 안에 있는지 판단해야 한다.

```
#include <iostream>

#define EPSILON 0.0001

bool FloatEQ(float x, float y) {
    if ((y - EPSILON) < x && x < (y + EPSILON)) {
        return true;
    }
    return false;
}

int main() {
    float a, b, c;

    a = 1.345f;
    b = 1.123f;
    c = a + b;

    if (FloatEQ(c, 2.468)) {
        std::cout << "동일O" << std::endl;
    } else {
        std::cout << "동일X" << std::endl;
    }
}
```