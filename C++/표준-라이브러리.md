- [컨테이너(container)](#컨테이너container)
- [반복자(iterator)](#반복자iterator)
- [알고리즘(algorithm)](#알고리즘algorithm)
- [std::string](#stdstring)
- [익명함수(anonymous function)](#익명함수anonymous-function)
- [람다식(lambda expression)](#람다식lambda-expression)
- [std::array](#stdarray)
- [std::vector](#stdvector)
- [std::forward\_list](#stdforward_list)
- [std::list](#stdlist)
- [std::deque](#stddeque)
- [std::stack](#stdstack)
- [std::queue](#stdqueue)
- [std::set](#stdset)
- [std::map](#stdmap)

# 컨테이너(container)
이때까지 우리가 작성한 거의 모든 프로그램의 기능은 표준 라이브러리(Standard Library, STL)로 대체가 가능하다. 심지어 빠르고, 안정적이고, 기본적으로 내장되어 설치도 필요없다!

STL은 크게 컨테이너(constainer), 반복자(iterator), 알고리즘(algorithm)으로 구성된다.

컨테이너는 자료 구조를 위한 템플릿 클래스이다. 스택이나 큐, 리스트와 같이 원소를 관리하는 집합과 같은 공간이머 컬렉션(Collection)이라고도 한다. 

# 반복자(iterator)
컨테이너의 원소들을 순회하기 위한 포인터라고 생각하면 된다. 컨테이너에 종속되지 않기 때문에 얼마든지 분리나 결합해 사용가능하다. 그러니까 다양한 컨테이너에 적용이 가능하고 컨테이너 내부 구조에 관계없이 일관된 방식으로 사용이 가능하다는 말이다. 반복자는 아래와 같은 공통 기능이 있다.

- 포인터 개념: 원소를 가리킨다.
- 원소 순회: ++, !=, == 등의 연산자를 지원한다.
- 시작과 끝 제공: begin(), end()를 제공한다.

모든 컨테이너는 반복자를 가지고 있다. 예를 들면 vector의 반복자는 vector::iterator에 선언되어있다. 컨테이너 내부에 있으므로 범위해결연산자 `::`를 사용한다.

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v{1, 2, 3, 4, 5};
    std::vector<int>::iterator itr;

    itr = v.begin();
    std::cout << *itr << std::endl; // 포인터니까 *itr

    itr++;
    std::cout << *itr << std::endl;

    // 반복자를 통한 순회
    itr = v.begin();
    while (itr != v.end()) {
        std::cout << *itr << std::endl;
        itr++;
    }

    // 위 코드를 압축하면 아래와 같은 형태
    // 이것을 쉽게 쓰도록 한 것이 범위 기반 반복문
    for (std::vector<int>::iterator itr = v.begin(); itr != v.end(); itr++) {
    // for (auto itr = v.begin(); itr != v.end(); itr++)과 동일
        std::cout << *itr << std::endl;
    }
}
```

auto 키워드는 컴파일러가 해석할 수 있으면 해당 타입으로 자동으로 변환해 사용해 준다. 따라서 어떤 타입인지 숙지가 필요하다.

```
#include <iostream>
#include <vector>

int main() {
    class Student {
    public:
        int mNumber;
    };

    std::vector<Student> students{{ 1 }, { 2 }, { 3 }};
    // 유니폼 초기화식으로 1, 2, 3번 학생을 벡터에 추가

    std::vector<Student>::iterator itr = students.begin();

    itr->mNumber = 0;
    // (*itr).mNumber = 0;와 동일

    std::vector<int> numbers{1, 2, 3, 4, 5};

    for (auto e : numbers) {
    // auto& e라면 실제로 값 변경
        e = 10; // 지역변수라서 실제 값은 변화 없음
    }
}
```

# 알고리즘(algorithm)
세계 최고의 프로그래머들이 미리 준비한 알고리즘 집합이다. 상상할 수 있는 거의 모든 기능이 있다. 컨테이너를 다룰 수 있는 전역 템플릿 함수들의 집합으로 되어 있고, 컨테이너와 분리되어 있어서 모든 컨테이너에게 적용할 수 있다.

핵심 기능인 위 세 가지 외에도 메모리 관리, 멀티 스레딩, 예외 처리 등의 추가 기능도 제공한다.

# std::string
문자를 원소로 가지는 컨테이너다. 아래 연산을 지원한다. s1은 std::string이고 s2는 std::string 또는 char*이다.

|            연산            |                      기능                      |
| :------------------------: | :--------------------------------------------: |
|          s1 = s2           |                  문자열 대입                   |
|          s1 += s2          |               문자열 더하고 대입               |
|           s1[i]            |                   첨자 접근                    |
|          s1 + s2           |       두 문자열을 더한 string 객체 반환        |
|   s1 == s2 또는 s1 != s2   |                 두 문자열 비교                 |
|    s1 > s2 또는 s1 < s2    |                  사전 순 비교                  |
| s1.size() 또는 s1.length() |                 문자열의 크기                  |
|         s1.c_str()         |        std::string을 char* 형태로 반환         |
|     s1.insert(pos, s2)     |           s1의 position에 s2를 삽입            |
|       s1.append(s2)        |            s1의 가장 뒤에 s2를 붙임            |
|       s1.erase(pos)        |       s1[pos]부터 시작하는 문자열을 지움       |
|      s1.erase(pos, n)      |         s1[pos]부터 n개의 문자를 지움          |
|        s1.findx(s2)        |   s1에서 s2를 찾아 첫번째 문자의 위치를 반환   |
|          in >> s1          | in으로부터 단어를 s1에 읽음(공백 시 입력 종료) |
|      getline(in, s1)       | in으로부터 문장을 s1에 읽음(엔터 시 입력 종료) |
|         out << s1          |             out으로부터 s1을 출력              |
|  s1.begin() 또는 s1.end()  |    문자열의 시작 또는 끝을 가리키는 반복자     |

> std::to_string(type val)
>
> `std::to_string(num)`과 같이 사용한다. 기본 타입을 문자열로 변환한다. int, float, double 등 기본 타입으로 오버로딩되어 있다.

> std::stoi(const string& str, size_t* idx = 0, int base = 10)
>
> `std::stoi(str)`과 같이 사용한다. C++ 11에 추가된 기능으로 문자열을 정수로 변환한다. 실수로 변환하는 stof도 있다.

일반적인 아스키코드로는 한국어와 같은 다국어와 특수 문자를 모두 표현하기 어렵다. 그래서 추가된 개념이 확장 문자로 C++에서는 wchar_t, std::wstring으로 이러한 문자와 문자열을 지원한다. 구분을 위해 접두어 `L""`을 붙인다.

```
#include <iostream>
#include <string>
#include <locale> // 다국어 지원
#include <sstream> // 문자열 스트림

int main() {
    // 유니코드 대응화가 아닌 편법으로 옛날 방식 사용
    std::string s1{ "가나다라마바사" };
    std::cout << s1 << std::endl;

    char ch1 = 'A';
    wchar_t ch2 = L'나';
    std::wstring string = L"확장 문자열";

    _wsetlocale(LC_ALL, L"korean");
    std::wcout.imbue(std::locale("korean"));
    std::cout << ch1 << std::endl;
    std::wcout << ch2 << std::endl; // 유니코드 한글 출력

    std::string nick{ "Doggy" };
    int rarity{ 5 };
    std::string itemName{ "서리한" };

    // C++ 스타일
    std::ostringstream oss;
    oss << nick << "님이 " << rarity << "성 " << itemName << "을/를 강화 성공!" << std::endl;
    std::cout << oss.str() << std::endl;

    // C 스타일
    char output[512];
    snprintf(output, sizeof(output),
             "%s님이 %d성 %s을/를 강화 성공!",
             nick.c_str(), rarity, itemName.c_str());
    std::cout << output << std::endl;
}
```

wsprintf_s()와 같이 출력할 때 포맷을 지정하였다. C++에서는 조금 더 세련된 기능을 지원한다.

|                 포맷                 |          기능           |                   예시                   |
| :----------------------------------: | :---------------------: | :--------------------------------------: |
|               std::dec               |       10진수 정수       |     std::cout << std::dec << myInt;      |
|               std::hec               |       16진수 정수       |     std::cout << std::hec << myInt;      |
|               std::oct               |       8진수 정수        |     std::cout << std::oct << myInt;      |
|            std:boolalpha             | bool형(true 또는 false) |  std::cout << std::boolalpha << myBool;  |
|              std::fixed              |       고정 소수점       |   std::cout << std::fixed << myFloat;    |
|           std::scientific            |        지수 표현        | std::cout << std::scientific << myFloat; |
|              std::left               |        왼쪽 정렬        |     std::cout << std::left << myInt;     |
|              std::right              |       오른쪽 정렬       |    std::cout << std::right << myInt;     |
| ios_base::precision(streamsize prec) |       정밀도 지정       |         std::cout.precision(5);          |
|    ios_base::width(streamsize w)     |     출력 너비 지정      |           std::cout.width(10);           |
|        ios::fill(char fillch)        | 여백을 채울 문자열 지정 |           std::cout.fill('0');           |

# 익명함수(anonymous function)

# 람다식(lambda expression)

# std::array

# std::vector
벡터는 가변 크기의 배열을 효율적으로 관리하는 컨테이너다. 동적 배열과 유사하게 스택에 포인터 변수를 만들고 힙의 메모리를 가리킨다. 벡터 객체를 간단히 설명하면 다음과 같다.

- 벡터 객체는 원소의 타입을 정하여 만든다.
- 벡터 객체는 원소들의 크기와 원소들의 시퀀스에 대한 포인터를 가지고 있다.
- 원소들의 시퀀스는 0에서 size-1까지 첨자 연산자 `[]`를 사용해 접근한다.

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v{2, 3, 1, 5, 6};
    std::vector<std::string> v2{ "doggy", "kitty", "bunny" };

    for (int i{}; i < v2.size(); i++) {
        std::cout << v2[i] << std::endl;
    }

    // 생성자가 다양함
    std::vector<int> v3(5); // 5개 생성
    std::vector<int> v4(5, 10); // 5개를 생성하고 10으로 초기화
    std::vector<int> v6{4}; // { 4 }
    std::vector<int> v7(4); // { 0,0,0,0 }

    // C++ 11 대격변 패치 이후 생긴 변화
    for (int i : v4) { // 범위 기반 반복문
        std::cout << i << std::endl;
    }

    std::vector<int> v5;
    v5.push_back(2); // 크기를 자유롭게 수정 가능
    v5.pop_back();
}
```

범위 기반 반복문의 단점은 인덱스를 모르기 때문에 직접 인덱스에 접근해 사용하기가 어렵다.

# std::forward_list

# std::list

# std::deque

# std::stack

# std::queue

# std::set

# std::map