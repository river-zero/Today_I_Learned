- [컨테이너(container)](#컨테이너container)
- [오버헤드(overhead)](#오버헤드overhead)
- [반복자(iterator)](#반복자iterator)
- [알고리즘(algorithm)](#알고리즘algorithm)
- [람다식(lambda expression)](#람다식lambda-expression)
- [std::string](#stdstring)
- [std::vector](#stdvector)
- [std::array](#stdarray)
- [std::forward\_list](#stdforward_list)
- [std::list](#stdlist)
- [std::deque](#stddeque)
- [std::stack](#stdstack)
- [std::queue](#stdqueue)
- [std::set](#stdset)
- [std::map](#stdmap)

# 컨테이너(container)
이때까지 우리가 작성한 거의 모든 프로그램의 기능은 표준 라이브러리(Standard Library, STL)로 대체가 가능하다. 심지어 빠르고, 안정적이고, 기본적으로 내장되어 설치도 필요없다!

STL은 크게 컨테이너(constainer), 반복자(iterator), 알고리즘(algorithm)으로 구성된다.

컨테이너는 자료 구조를 위한 템플릿 클래스이다. 스택이나 큐, 리스트와 같이 원소를 관리하는 집합과 같은 공간이머 컬렉션(Collection)이라고도 한다. 컨테이너는 특징에 따라서 크게 세 가지로 구분할 수 있다.

> 순차 컨테이너(Sequence Container)
>
> 원소들이 순서대로 나열되어 있는 컨테이너다. 원소를 추가해도 순서를 유지한다.

> 보조 컨테이너(Container Adapter)
>
> 특정한 목적에 맞도록 변형된 컨테이너다.

> 연관 컨테이너(Associative Container)
>
> 원소들이 상하 또는 좌우로 서로 관련이 있는 컨테이너다. 원소들끼리 부모와 자식 관계를 가지기도 한다. 원소를 추가하면 미리 정의된 순서에 따라 정렬된다. 

|     분류      |    컨테이너    |               설명               |
| :-----------: | :------------: | :------------------------------: |
| 순차 컨테이너 |     array      |               배열               |
|               |     vector     |            가변 배열             |
|               |  forward_list  |         단일 연결 리스트         |
|               |      list      |        양방향 연결 리스트        |
|               |     deque      |            양방향 큐             |
| 보조 컨테이너 |     stack      |         LIFO 방식의 스택         |
|               |     queue      |          FIFO 방식의 큐          |
|               | priority_queue |         우선순위 적용 큐         |
| 연관 컨테이너 |      set       |  이진 탐색 트리 기반의 단일 키   |
|               |    multiset    |     여러 개의 키를 가진 set      |
|               |      map       | 이진 탐색 트리 기반 <key, value> |
|               |    multimap    |     여러 개의 키를 가진 map      |

# 오버헤드(overhead)
예상된느 저장공간 외에 추가되는 값으로 간접 비용이라고 생각할 수 있다. 정수 원소 4개를 가지고 있는 컨테이너는 총 16바이트가 예상되지만 내부적으로 처리하기 위해 추가적으로 메모리가 더 필요할 수 있다. 이를 메모리 오버헤드라고 한다.

메모리 접근 방식에서 임의 접근(random access)는 직접 접근이라고도 하며 원소가 포함된 메모리를 상수 시간에 가져올 수 있다. 그리고 순차 접근(sequential access)는 처음 혹은 끝부터 순서대로 접근해 원소를 가져온다.

# 반복자(iterator)
컨테이너의 원소들을 순회하기 위한 포인터라고 생각하면 된다. 컨테이너에 종속되지 않기 때문에 얼마든지 분리나 결합해 사용가능하다. 그러니까 다양한 컨테이너에 적용이 가능하고 컨테이너 내부 구조에 관계없이 일관된 방식으로 사용이 가능하다는 말이다. 반복자는 아래와 같은 공통 기능이 있다.

- 포인터 개념: 원소를 가리킨다.
- 원소 순회: ++, !=, == 등의 연산자를 지원한다.
- 시작과 끝 제공: begin(), end()를 제공한다.

모든 컨테이너는 반복자를 가지고 있다. 예를 들면 vector의 반복자는 vector::iterator에 선언되어있다. 컨테이너 내부에 있으므로 범위해결연산자 `::`를 사용한다.

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v{1, 2, 3, 4, 5};
    std::vector<int>::iterator itr;

    itr = v.begin();
    std::cout << *itr << std::endl; // 포인터니까 *itr

    itr++;
    std::cout << *itr << std::endl;

    // 반복자를 통한 순회
    itr = v.begin();
    while (itr != v.end()) {
        std::cout << *itr << std::endl;
        itr++;
    }

    // 위 코드를 압축하면 아래와 같은 형태
    // 이것을 쉽게 쓰도록 한 것이 범위 기반 반복문
    for (std::vector<int>::iterator itr = v.begin(); itr != v.end(); itr++) {
    // for (auto itr = v.begin(); itr != v.end(); itr++)과 동일
        std::cout << *itr << std::endl;
    }
}
```

auto 키워드는 컴파일러가 해석할 수 있으면 해당 타입으로 자동으로 변환해 사용해 준다. 따라서 어떤 타입인지 숙지가 필요하다.

```
#include <iostream>
#include <vector>

int main() {
    class Student {
    public:
        int mNumber;
    };

    std::vector<Student> students{{ 1 }, { 2 }, { 3 }};
    // 유니폼 초기화식으로 1, 2, 3번 학생을 벡터에 추가

    std::vector<Student>::iterator itr = students.begin();

    itr->mNumber = 0;
    // (*itr).mNumber = 0;와 동일

    std::vector<int> numbers{1, 2, 3, 4, 5};

    for (auto e : numbers) {
    // auto& e라면 실제로 값 변경
        e = 10; // 지역변수라서 실제 값은 변화 없음
    }
}
```

# 알고리즘(algorithm)
세계 최고의 프로그래머들이 미리 준비한 알고리즘 집합이다. 상상할 수 있는 거의 모든 기능이 있다. 컨테이너를 다룰 수 있는 전역 템플릿 함수들의 집합으로 되어 있고, 컨테이너와 분리되어 있어서 모든 컨테이너에게 적용할 수 있다.

핵심 기능인 위 세 가지 외에도 메모리 관리, 멀티 스레딩, 예외 처리 등의 추가 기능도 제공한다.

알고리즘 파트에서 맨땅에 헤딩으로 구현한 퀵 정렬도 아래와 같이 짧게 구현이 가능하다.

```
#include <iostream>
#include <vector>
#include <algorithm>

int IntCompare(const void* left, const void* right) {
    int lhs = *static_cast<const int*>(left);
    int rhs = *static_cast<const int*>(right);

    if (lhs > rhs) {
        return -1;
    } else if (lhs < rhs) {
        return 1;
    }
    return 0;
}

int main() {
    std::vector<int> v{ 1, 2, 3 };

    qsort(v.data(), v.size(), sizeof(v[0]), IntCompare);
    // 시작 포인터, 원소 개수, 원소 하나의 크기, 원소를 비교한 조건식 

    for (int value : v) {
        std::cout << value << " "; // 3 2 1 내림차순으로 출력
    }
}
```

정렬에 딱 한 번 사용되는 비교 함수를 위해서 새로 함수를 정의하는 것은 조금 귀찮은 일이다. 그래서 등장한 개념이 람다식이다. 아래는 여러 알고리즘 예시다.

```
#include <iostream>
#include <vector>
#include <algorithm>

// { 1, 2, 3, 4 } 형식으로 출력하기 위한 << 연산자 오버로딩
std::ostream& operator<<(std::ostream& os, std::vector<int> v) {
    os << "{ ";
    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) {
        os << *it;
        if (it != v.end() - 1) {
            os << ", ";
        }
    }
    os << " }";
    return os;
}

int main() {
    std::vector<int> numbers{ 5, 2, 3, 1, 4 };

    // std::min 함수
    int x = 5, y = 3;
    std::cout << std::min(x, y) << std::endl;
    std::cout << std::min({ 1,2,3,4,5 }) << std::endl;

    // std::min_element 함수
    std::vector<int>::iterator result = std::min_element(numbers.begin() + 2, numbers.end());
    std::cout << *result << std::endl;
    std::cout << result - numbers.begin() << std::endl; // 5부터 1까지는 세 칸이므로 3 출력

    // std::swap 함수
    std::vector<int> numbers2{ 0, 0, 0 };
    std::swap(numbers, numbers2);
    for (const auto& e : numbers2) { // 5, 2, 3, 1, 4,
        std::cout << e << ", ";
    }
    std::cout << std::endl;

    std::cout << numbers << std::endl; // { 0, 0, 0 }
    std::cout << numbers2 << std::endl; // { 5, 2, 3, 1, 4 }

    // std::sort 함수
    struct CompareObject {
        bool operator()(int x, int y) { // 두 정수 비교 연산
            return x > y;
        }
    };
    CompareObject c;
    std::sort(numbers2.begin(), numbers2.end(), c); // 오름차순 정렬
    std::cout << numbers2 << std::endl; // { 5, 4, 3, 2, 1 }

    // std::greater 함수 사용 시
    std::sort(numbers.begin(), numbers.end(), std::greater<int>());

    // 람다식 사용 시
    std::sort(numbers2.begin(), numbers2.end(), [](int x, int y) {
        return x > y;
    });

    std::cout << numbers << std::endl; // { 0, 0, 0 }
}
```

알고리즘 안에서 범위 기반 반복문과 비슷한 기능을 수행하는 것이 std::for_each 함수이다. 주어진 범위의 요소들을 순회하면서 사용자가 제공한 함수나 함수 객체를 수행한다. 시작과 끝을 지정해 줄 수 있고 클래스로 되어 있어 함수처럼 작동해 유연한 코딩이 가능하다.

단순한 순회 처리는 범위 기반 반복문을 쓰고 복잡한 연산이 필요한 경우 std::for_each 함수를 쓴다고 이해해도 된다.

```
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = { 10, 20, 30, 40, 50 };

    // 인덱스 버전
    for (int i = 0; i < numbers.size(); i++) {
        std::cout << numbers[i] << std::endl;
    }
    std::cout << "-----" << std::endl;

    // iterator 버전
    for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); it++) {
        std::cout << *it << std::endl;
    }
    std::cout << "-----" << std::endl;

    // 범위 기반 반복문 버전
    for (const auto& e : numbers) {
        std::cout << e << std::endl;
    }
    std::cout << "-----" << std::endl;

    // for_each 버전
    std::for_each(numbers.begin(), numbers.end(), [](const int& val) {
        std::cout << val << std::endl;
    });
}
```

# 람다식(lambda expression)
코드 내에 함수를 선언 없이 삽입하는 기법이다. `[](int a, int b) {}` 또는 `[](int a) -> int {return result;}`와 같은 형태로 사용한다. 퀵 정렬 구현을 마무리하면 아래와 같다. 

```
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v{ 1, 2, 3 };

    qsort(v.data(), v.size(), sizeof(v[0]), [](const void* a, const void* b) {
        return *static_cast<const int*>(b) - *static_cast<const int*>(a);
    });

    for (int value : v) {
        std::cout << value << " "; // 3 2 1 내림차순으로 출력
    }
}
```

# std::string
문자를 원소로 가지는 컨테이너다. 아래 연산을 지원한다. s1은 std::string이고 s2는 std::string 또는 char*이다.

|            연산            |                      기능                      |
| :------------------------: | :--------------------------------------------: |
|          s1 = s2           |                  문자열 대입                   |
|          s1 += s2          |               문자열 더하고 대입               |
|           s1[i]            |                   첨자 접근                    |
|          s1 + s2           |       두 문자열을 더한 string 객체 반환        |
|   s1 == s2 또는 s1 != s2   |                 두 문자열 비교                 |
|    s1 > s2 또는 s1 < s2    |                  사전 순 비교                  |
| s1.size() 또는 s1.length() |                 문자열의 크기                  |
|         s1.c_str()         |        std::string을 char* 형태로 반환         |
|     s1.insert(pos, s2)     |           s1의 position에 s2를 삽입            |
|       s1.append(s2)        |            s1의 가장 뒤에 s2를 붙임            |
|       s1.erase(pos)        |       s1[pos]부터 시작하는 문자열을 지움       |
|      s1.erase(pos, n)      |         s1[pos]부터 n개의 문자를 지움          |
|        s1.findx(s2)        |   s1에서 s2를 찾아 첫번째 문자의 위치를 반환   |
|          in >> s1          | in으로부터 단어를 s1에 읽음(공백 시 입력 종료) |
|      getline(in, s1)       | in으로부터 문장을 s1에 읽음(엔터 시 입력 종료) |
|         out << s1          |             out으로부터 s1을 출력              |
|  s1.begin() 또는 s1.end()  |    문자열의 시작 또는 끝을 가리키는 반복자     |

> std::to_string(type val)
>
> `std::to_string(num)`과 같이 사용한다. 기본 타입을 문자열로 변환한다. int, float, double 등 기본 타입으로 오버로딩되어 있다.

> std::stoi(const string& str, size_t* idx = 0, int base = 10)
>
> `std::stoi(str)`과 같이 사용한다. C++ 11에 추가된 기능으로 문자열을 정수로 변환한다. 실수로 변환하는 stof도 있다.

일반적인 아스키코드로는 한국어와 같은 다국어와 특수 문자를 모두 표현하기 어렵다. 그래서 추가된 개념이 확장 문자로 C++에서는 wchar_t, std::wstring으로 이러한 문자와 문자열을 지원한다. 구분을 위해 접두어 `L""`을 붙인다.

```
#include <iostream>
#include <string>
#include <locale> // 다국어 지원
#include <sstream> // 문자열 스트림

int main() {
    // 유니코드 대응화가 아닌 편법으로 옛날 방식 사용
    std::string s1{ "가나다라마바사" };
    std::cout << s1 << std::endl;

    char ch1 = 'A';
    wchar_t ch2 = L'나';
    std::wstring string = L"확장 문자열";

    _wsetlocale(LC_ALL, L"korean");
    std::wcout.imbue(std::locale("korean"));
    std::cout << ch1 << std::endl;
    std::wcout << ch2 << std::endl; // 유니코드 한글 출력

    std::string nick{ "Doggy" };
    int rarity{ 5 };
    std::string itemName{ "서리한" };

    // C++ 스타일
    std::ostringstream oss;
    oss << nick << "님이 " << rarity << "성 " << itemName << "을/를 강화 성공!" << std::endl;
    std::cout << oss.str() << std::endl;

    // C 스타일
    char output[512];
    snprintf(output, sizeof(output),
             "%s님이 %d성 %s을/를 강화 성공!",
             nick.c_str(), rarity, itemName.c_str());
    std::cout << output << std::endl;
}
```

wsprintf_s()와 같이 출력할 때 포맷을 지정하였다. C++에서는 조금 더 세련된 기능을 지원한다.

|                 포맷                 |          기능           |                   예시                   |
| :----------------------------------: | :---------------------: | :--------------------------------------: |
|               std::dec               |       10진수 정수       |     std::cout << std::dec << myInt;      |
|               std::hec               |       16진수 정수       |     std::cout << std::hec << myInt;      |
|               std::oct               |       8진수 정수        |     std::cout << std::oct << myInt;      |
|            std:boolalpha             | bool형(true 또는 false) |  std::cout << std::boolalpha << myBool;  |
|              std::fixed              |       고정 소수점       |   std::cout << std::fixed << myFloat;    |
|           std::scientific            |        지수 표현        | std::cout << std::scientific << myFloat; |
|              std::left               |        왼쪽 정렬        |     std::cout << std::left << myInt;     |
|              std::right              |       오른쪽 정렬       |    std::cout << std::right << myInt;     |
| ios_base::precision(streamsize prec) |       정밀도 지정       |         std::cout.precision(5);          |
|    ios_base::width(streamsize w)     |     출력 너비 지정      |           std::cout.width(10);           |
|        ios::fill(char fillch)        | 여백을 채울 문자열 지정 |           std::cout.fill('0');           |

# std::vector
벡터는 가변 크기의 배열을 효율적으로 관리하는 컨테이너다. 동적 배열과 유사하게 스택에 포인터 변수를 만들고 힙의 메모리를 가리킨다. 벡터 객체를 간단히 설명하면 다음과 같다.

- 벡터 객체는 원소의 타입을 정하여 만든다.
- 벡터 객체는 원소들의 크기와 원소들의 시퀀스에 대한 포인터를 가지고 있다.
- 원소들의 시퀀스는 0에서 size-1까지 첨자 연산자 `[]`를 사용해 접근한다.

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v{2, 3, 1, 5, 6};
    std::vector<std::string> v2{ "doggy", "kitty", "bunny" };

    for (int i{}; i < v2.size(); i++) {
        std::cout << v2[i] << std::endl;
    }

    // 생성자가 다양함
    std::vector<int> v3(5); // 5개 생성
    std::vector<int> v4(5, 10); // 5개를 생성하고 10으로 초기화
    std::vector<int> v6{4}; // { 4 }
    std::vector<int> v7(4); // { 0,0,0,0 }

    // C++ 11 대격변 패치 이후 생긴 변화
    for (int i : v4) { // 범위 기반 반복문
        std::cout << i << std::endl;
    }

    std::vector<int> v5;
    v5.push_back(2); // 크기를 자유롭게 수정 가능
    v5.pop_back();
}
```

범위 기반 반복문의 단점은 인덱스를 모르기 때문에 직접 인덱스에 접근해 사용하기가 어렵다.

# std::array
순차 컨테이너 중 하나로 고정 크기의 배열과 비슷한 역할을 수행하지만 STL의 알고리즘과 반복자 등의 기능을 사용할 수 있다는 장점을 가지고 있다. 주요 특징은 다음과 같다.

> 순차적(Sequence)
>
> 원소들이 정해진 순서대로 저장되며 각 원소는 이 순서대로 접근할 수 있다. 그러니까 순서대로 순회하거나 인덱스를 사용해 랜덤 액세스가 가능하다.

> 연속된 저장 공간(Contiguous)
>
> 연속된 메모리 공간에 원소를 저장한다. 따라서 포인터 연산을 사용해 원소 간 이동이 가능하며 랜덤 액세스가 상수 시간에 가능하다.

> 고정 크기
>
> std::array의 크기는 컴파일 시간에 결정된다. 정확히 원소의 개수만큼 메모리를 차지하며 메모리 할당에 시간이 필요치 않다.

# std::forward_list

# std::list

# std::deque

# std::stack

# std::queue

# std::set

# std::map