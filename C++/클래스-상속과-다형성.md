# 상속(inheritance)
과학 시간에 많이 듣던 분류와 같은 개념이다. 개는 포유강이고 개과에 속하므로 개는 포유강의 속성과 개과의 속성을 모두 가지는 것처럼 is-a 관계를 가진다. 개는 포유강을 상속(inheritance) 또는 포유강에서 파생(derivation)된 것이다.

C++에서 파생은 `class <파생 클래스> : [virtual] [접근제한자] <기반 클래스>, …`과 같이 사용한다. 접근제한자는 상속 받는 범위를 지정하는데 생략하면 기본적으로 private이 된다. 각 제한자별로 상태 변화는 아래 표와 같다. 파생될 때의 접근제한자에 따라 기반 클래스의 멤버들의 접근 제한이 변경된다.

| base class 멤버 | public 상속 | protected 상속 | private 상속 |
| :-------------: | :---------: | :------------: | :----------: |
|     public      |   public    |   protected    |   private    |
|    protected    |  protected  |   protected    |   private    |
|     private     |  접근 불가  |   접근 불가    |  접근 불가   |

protected 접근제한자는 상속과 캡슐화를 모두 만족한다. 클래스 외부에서는 보이지 않으나 상속된 클래스 내부에서는 접근이 가능하다. 따라서 파생 관계를 구현할 때는 한 번쯤 protected를 생각해 보는 것이 좋다.

```
// Animal.h - - - - - - - - - - - - - - - - - - - - - - - - - - -
#pragma once

class Animal {
protected:
    int mAge;
    int mWeight;

public:
    Animal();
    ~Animal();

    int GetAge() const;
    void SetAge(int age);
    int GetWeight() const;
    void SetWeight(int weight);
    
    void Sound();
};

// Animal.cpp - - - - - - - - - - - - - - - - - - - - - - - - - - -
#include <iostream>
#inlcude “Animal.h”

Animal::Animal() : mAge(1), mWeight(1) {}

Animal::~Animal() {}

int Animal::GetAge() const {
    return mAge;
}

void Animal::SetAge(int age) {
    mAge = age;
}

int Animal::GetWeight() const {
    return mWeight;
}

void Animal::SetWeight(int weight) {
    mWeight = weight;
}

void Animal::Sound() {
    std::cout << “Make a noise…” << std::endl;
}

// Dog.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#pragma once
#include “Animal.h”
class Dog : public Animal {
public:
    enum BREED {
        BEAGLE, DOBERMAN, BERNARD, HUSKY, JINDO
    };

private:
    BREED mBreed;

public:
    Dog();
    ~Dog();

    Dog::BREED GetBreed() const;
    void SetBreed(Dog::BREED breed);

    void Roll();
};

// Dog.cpp - - - - - - - - - - - - - - - - - - - - - - - - - - -
#include <iostream>
#include “Dog.h”

Dog::Dog() : mBreed{ BREED::JINDO } {}

Dog::~Dog() {}

Dog::BREED Dog::GetBreed() const {
    return mBreed;
}

void Dog::SetBreed(Dog::BREED breed) {
    mBreed = breed;
}

void Dog::Roll() {
    std::cout << “Rolling…” << std::endl;
}

// Main.cpp - - - - - - - - - - - - - - - - - - - - - - - - - - -
#include <iostream>
#include “Dog.h”

int main() {
    Dog john;
    john.Sound();
    john.Roll();
}
```

BREED 열거형은 Dog 클래스 종속이므로 외부에서 사용하기 위한 Getter/Setter 함수에서는 범위해결연산자 `::`를 붙여야 한다.

생성은 소멸의 역순이므로 위 코드에서도 생성은 기반 클래스부터이고 파괴는 파생 클래스부터이다.

유지보수와 오류파악이 쉬운 프로그램을 위해 생성자는 각각 자신의 멤버들만 관리하고, 파생 클래스에서 기반 클래스의 생성자를 호출하는 방식이 좋다. 앞서 배운 내용에서 멤버 초기화 리스트와 대리 생성자는 공존이 불가능하다고 했지만 부모 생성자를 불러내도 내 멤버 초기화 리스트는 사용이 가능하다. 원래는 암시적으로 부모 생성자를 대리로 불러냈던 것이어서 부모에서 자식으로 생성되었던 것이다.