- [예외](#예외)
- [컴파일시간 오류](#컴파일시간-오류)
- [실행시간 오류](#실행시간-오류)
- [링크시간 오류](#링크시간-오류)
- [오류의 원인](#오류의-원인)
- [exception](#exception)
- [throw](#throw)
- [try](#try)
- [catch](#catch)
- [디버깅](#디버깅)

# 예외
유저는 절대 프로그래머가 의도한 대로 행동하지 않는다. 좋은 프로그래머는 다양한 예외를 예측할 수 있어야 한다.

# 컴파일시간 오류
문법을 지키지 않거나 타입에 지원되지 않는 연산을 수행할 때 발생하는 오류로 컴파일러로 잡아낼 수 있다.

# 실행시간 오류
컴퓨터가 허용하지 않은 계산을 하려고 하거나, 라이브러리가 허용하지 않은 계산이거나, 프로그래머가 직접 허용되지 않는 계산을 지정하거나 할 때 발생하는 오류로 프로그래머가 꼼꼼하다면 예방하거나 수정할 수 있다.

# 링크시간 오류
링커가 탐지한 오류로 주로 외부 라이브러리의 잘못된 사용으로 발생한다. 비교적 수정하기 쉽다.

# 오류의 원인
- 잘못된 명세

기획 단계에서부터 잘못된 경우다.

- 불완전한 프로그램

시간에 쫓기는 게임 개발의 특성상 어쩔 수 없이 발생하게 된다.

- 예상 밖의 인자

나이를 입력받는 함수가 음수를 매개변수로 받는 경우에 해당한다.

- 예상 밖의 입력

유저는 정말로 기상천외한 입력을 할 수 있음을 기억하자.

- 예상 밖의 상태

주어진 입력을 계산하기 위해 배열을 사용하는데 이 배열의 내용이 이미 잘못된 경우에 해당한다. 

- 논리 오류

프로그래머의 실수다. 컴파일과 실행은 정상적으로 실행되는 엉터리 프로그램으로 디버깅으로 하니씩 추적해 나가는 수밖에 없다.

# exception
프로그램은 실행 도중 예상치 못한 오류로 중지되거나 튕기기도 한다. 이러한 오류에 대한 처리를 지원하는 것이 예외(exception)이다.

# throw
오류가 발생하면 예외를 던진다.

# try
호출한 쪽에서 일단 먼저 계산을 시도한다.

# catch
던져진 예외를 잡아서 해당 예외에 대한 처리를 수행한다.

```
#include <iostream>

double LinearEquation(int a, int b) {
    if (a == 0) {
        throw std::logic_error("0으로 나눔");
    }

    return -(double)b / a;
}

int main() {
    int a, b;

    std::cin >> a >> b;

    try {
        std::cout << LinearEquation(a, b);
    }
    catch (std::logic_error e) {
        std::cerr << e.what() << std::endl;
    }
}
```

마이크로소프트 비주얼 스튜디오에서 지원하는 디버그 모드 전용인 예외 처리로는 `assert()`가 있다.

```
#include <iostream>
#include <cassert>

int main() {
    int a, b;

    std::cin >> a >> b;

    assert(a != 0);
}
```

# 디버깅
기본적으로 버그 사냥은 프로그램을 빌드하고 의도대로 작동하는지 확인하는 걸 반복한다.

1. 잘못된 결과와 입력(조건)
2. 비정상 동작하는 함수
3. 입력값 평가(사전 조건)
4. 결과값 평가(사후 조건)
5. 오류를 찾아서 수정
6. 다시 한 번 테스트 수행

적절한 주석과 예외 처리로 조금 더 쾌적한 디버깅이 가능하다.