- [upcast vs downcast](#upcast-vs-downcast)
- [static\_cast](#static_cast)
- [dynamic\_cast](#dynamic_cast)

# upcast vs downcast
전사 전용 스킬 함수는 형변환을 함으로써 가능해진다.

|상향 변환(up-cast)|하향 변환(down-cast)|
|:---:|:---:|
|파생클래스 → 기반클래스|기반클래스 → 파생클래스|
|안전한 변환이라 암시적 변환도 충분|런타임에 체크하지 않으면 결과 모름|
|컴파일 타임|런타임|
|빠름|느림|
|Character* p = new Warrior;|((Warrior*)p)->DoubleSlash();

# static_cast
컴파일 타임에 형변환을 결정하는 연산자다. `static_cast <new_type> (expression)` 이런 식으로 사용한다. 어떤 타입을 어떤 타입으로 변환하는지 확실하게 알고 싶다면 정적변환을 사용하면 된다.

```
Warrior* pWarrior = static_cast<Warrior*>(pHero);

if (pWarrior == nullptr) {
    std::cout << “error occurred.” << std::endl;
} else {
    pWarrior->DoubleSlash();
}
```

# dynamic_cast
런타임에 동적으로 타입을 변환하는 연산잔다. `dynamic_cast <new_type> (expression)` 이런 식으로 사용한다. 간혹 특정 컴파일러는 RTTI라는 실행시간에 동적으로 판단하기 위한 정보들이 꺼져있을 수도 있으니 활성화해주어야 한다.

dynamic_cast는 클래스의 참조형 또는 포인터에만 사용이 가능하므로 이에 쓰고 나머지는 static_cast를 쓴다고 생각해도 무방하다. 정적변환은 성능면에서 조금 더 유리하고 동적변환은 더 안정적으로 프로그래밍이 가능하다.

```
#include <iostream>

class Character {
protected:
    int mHP;

public:
    Character() : mHP{} {
        std::cout << "[+] Character" << std::endl;
    }
    virtual ~Character() {
        std::cout << "[-] Character" << std::endl;
    }

public:
    virtual void Attack() const {
        std::cout << "Unknown Attack..." << std::endl;
    }
};

class Warrior : public Character {
public:
    Warrior() {
        std::cout << "[+] Warrior" << std::endl;
    }
    ~Warrior() {
        std::cout << "[-] Warrior" << std::endl;
    }

public:
    void Attack() const override {
        std::cout << "Warrior Attack!" << std::endl;
    }
    void DoubleSlash() const {
        std::cout << "Warrior Double Slash!!" << std::endl;
    }
};

int main() {
    Character* p = new Warrior;

    p->Attack(); // Warrior Attack!
    ((Warrior*)p)->DoubleSlash(); // Warrior Double Slash!!

    // static_cast<Warrior*>(p);

    Warrior* wp = dynamic_cast<Warrior*>(p);
    if (wp) {
        wp->DoubleSlash(); // Warrior Double Slash!!
    } else {
        std::cerr << "* dynamic cast error" << std::endl;
    } // 훨씬 안전

    delete p;
}
```

이 외에도 reinterpret_cast라는 어떠한 형변환도 수행하려고 하는 위험하지만 유용한 형변환이 있다. 주로 데이터를 파일로 변환하거나 할 때 사용한다. 또, 상수를 변환해주는 const_cast도 있다. 포인터 참조형만 가능하며 const 기호를 추가하거나 제거가 가능하다.