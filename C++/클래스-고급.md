- [upcast vs downcast](#upcast-vs-downcast)
- [static\_cast](#static_cast)
- [dynamic\_cast](#dynamic_cast)
- [순수 가상 함수(pure virtual function)](#순수-가상-함수pure-virtual-function)
- [추상 기반 클래스(abstract base class)](#추상-기반-클래스abstract-base-class)
- [인터페이스(interface)](#인터페이스interface)
- [멤버 함수 포인터(member function pointer)](#멤버-함수-포인터member-function-pointer)
- [namespace](#namespace)
- [using](#using)
- [template](#template)
- [explicit](#explicit)

# upcast vs downcast
전사 전용 스킬 함수는 형변환을 함으로써 가능해진다.

|상향 변환(up-cast)|하향 변환(down-cast)|
|:---:|:---:|
|파생클래스 → 기반클래스|기반클래스 → 파생클래스|
|안전한 변환이라 암시적 변환도 충분|런타임에 체크하지 않으면 결과 모름|
|컴파일 타임|런타임|
|빠름|느림|
|Character* p = new Warrior;|((Warrior*)p)->DoubleSlash();

# static_cast
컴파일 타임에 형변환을 결정하는 연산자다. `static_cast <new_type> (expression)` 이런 식으로 사용한다. 어떤 타입을 어떤 타입으로 변환하는지 확실하게 알고 싶다면 정적변환을 사용하면 된다.

```
Warrior* pWarrior = static_cast<Warrior*>(pHero);

if (pWarrior == nullptr) {
    std::cout << “error occurred.” << std::endl;
} else {
    pWarrior->DoubleSlash();
}
```

# dynamic_cast
런타임에 동적으로 타입을 변환하는 연산잔다. `dynamic_cast <new_type> (expression)` 이런 식으로 사용한다. 간혹 특정 컴파일러는 RTTI라는 실행시간에 동적으로 판단하기 위한 정보들이 꺼져있을 수도 있으니 활성화해주어야 한다.

dynamic_cast는 클래스의 참조형 또는 포인터에만 사용이 가능하므로 이에 쓰고 나머지는 static_cast를 쓴다고 생각해도 무방하다. 정적변환은 성능면에서 조금 더 유리하고 동적변환은 더 안정적으로 프로그래밍이 가능하다.

```
#include <iostream>

class Character {
protected:
    int mHP;

public:
    Character() : mHP{} {
        std::cout << "[+] Character" << std::endl;
    }
    virtual ~Character() {
        std::cout << "[-] Character" << std::endl;
    }

public:
    virtual void Attack() const {
        std::cout << "Unknown Attack..." << std::endl;
    }
};

class Warrior : public Character {
public:
    Warrior() {
        std::cout << "[+] Warrior" << std::endl;
    }
    ~Warrior() {
        std::cout << "[-] Warrior" << std::endl;
    }

public:
    void Attack() const override {
        std::cout << "Warrior Attack!" << std::endl;
    }
    void DoubleSlash() const {
        std::cout << "Warrior Double Slash!!" << std::endl;
    }
};

int main() {
    Character* p = new Warrior;

    p->Attack(); // Warrior Attack!
    ((Warrior*)p)->DoubleSlash(); // Warrior Double Slash!!

    // static_cast<Warrior*>(p);

    Warrior* wp = dynamic_cast<Warrior*>(p);
    if (wp) {
        wp->DoubleSlash(); // Warrior Double Slash!!
    } else {
        std::cerr << "* dynamic cast error" << std::endl;
    } // 훨씬 안전

    delete p;
}
```

이 외에도 reinterpret_cast라는 어떠한 형변환도 수행하려고 하는 위험하지만 유용한 형변환이 있다. 주로 데이터를 파일로 변환하거나 할 때 사용한다. 또, 상수를 변환해주는 const_cast도 있다. 포인터 참조형만 가능하며 const 기호를 추가하거나 제거가 가능하다.

# 순수 가상 함수(pure virtual function)
`virtual void Attack() const = 0;` 이런 식으로 사용한다. 해당 함수를 상속받아서 정의하지 않으면 인스턴스를 만들 수 없다. 그래서 반드시 오버라이딩해야 한다.

# 추상 기반 클래스(abstract base class)
약속 이외의 어떠한 역할도 하지 않는다. 오로지 규칙만 존재하는 것이다. 이러한 클래스를 추상 기반 클래스라고 부른다.

- 순수 가상 함수를 하나라도 포함한다.
- 파생 클래스에서 해당 함수들이 반드시 구현되어야 한다.
- 인스턴스를 만들 수 없다.
- 멤버함수의 정의가 없다.

기반 클래스에서 순수가상함수를 구현하지 못하는 것은 아니다. 모든 파생 클래스가 공통적으로 해야 할 작업이 있다면 아래처럼 구현하고 각 파생 클래스에서 `Character::Dead();`로 직접 호출하면 된다.

```
void Character::Dead() const {
    std::cout << “killed by something…” << std::endl;
}
```

상속과 다형성을 적극적으로 활용하는 중요한 개념 중에 하나로 유연하고 확장 가능한 프로그램을 작성할 수 있다.

# 인터페이스(interface)
순수 가상 함수들로만 이뤄진 추상 클래스를 인터페이스라고도 부른다.

# 멤버 함수 포인터(member function pointer)
```
#include <iostream>

class MyClass {
public:
    int MyMemberFunction(float x) {
        std::cout << "멤버함수 호출" << std::endl;
        return 0;
    }
    static float MyStaticFunction(int x) {
        std::cout << "정적함수 호출" << std::endl;
        return 0;
    }
};

using FPtr1 = int (MyClass::*)(float); // 멤버 함수 포인터 타입
using FPtr2 = float (*)(int); // 정적 함수 포인터 타입

int main() {
    MyClass c;

    FPtr1 p1 = &MyClass::MyMemberFunction;
    (c.*p1)(1.1f);

    FPtr2 p2 = &MyClass::MyStaticFunction;
    p2(1);
    (*p2)(1);
}
```

```
#include <iostream>

class MyFunctions {
public:
    int NormalFunction(int x) {
        return x;
    }    
    static int SquareFunction(int x) {
        return x * x;
    }
};

using MemberFunctionPtr = int (MyFunctions::*)(int);  MyFunction -> MyFunctions
using StaticFunctionPtr = int (*)(int);

int Sigma(MyFunctions& instance, MemberFunctionPtr f, int m, int n) {
    int sum = 0;
    for (int i = m; i <= n; i++) {
        sum += (instance.*f)(i);
    }
    return sum;
}

int main() {
    MyFunctions mf; // 정적 멤버 함수만 있다면 필요 없음
    std::cout << Sigma(mf, &MyFunctions::NormalFunction, 1, 10) << std::endl;
    std::cout << Sigma(mf, &MyFunctions::SquareFunction, 1, 10) << std::endl;
}
```

멤버 함수는 클래스에 속하므로 범위 해결 지정자 `::`를 사용해 클래스에 속한다고 알려주어야 한다. 그리고 일반 함수는 암시적으로 함수 포인터로 변환되지만 멤버 함수는 그렇지 않기 때문에 주소를 넘겨준다.

인스턴스화 하지 않고 객체에 접근하는 방법은 정적 멤버 밖에 없다. 이때 정적 함수는 클래스 안에 있는 전역 함수처럼 작동한다. 

정적 멤버 함수가 아닌 일반 멤버 함수가 꼭 필요한 경우에는 인스턴스가 무조건 필요하다.

# namespace
이름 충돌을 피하기 위해서 코드를 그룹화하고 구분하는 방법이다.

```
namespace Game {
    class Warrior {
    public:
        void DoubleSlash() {}
    };

    void Print() {}

    int gCounter{};
}

namespace GUI {
    void Print() {}
}
```

위와 같이 사용을 하며 클래스, 함수, 변수 모두 사용이 가능하다. 원래라면 함수 이름이 같아서 동일한 이름으로 생성할 수 없지만 namespace를 사용하면 가능해진다.

```
int main() {
    Game::Warrior warrior;
    warrior.DoubleSlash();

    Game::Print();

    Game::gCounter++;

    GUI::Print();
}
```

namespace에 접근하기 위해서는 범위해결연산자 `::`를 사용해야 한다. 위 코드의 warrior같이 인스턴스화된 객체는 namespace에 속하지 않아 바로 사용이 가능하다. 어떠한 이름 공간도 지정하지 않으면 전역 이름공간에 포함되는 것이다. 전역 이름공간을 명시적으로 표현하자면 `::MyFunc()`와 같이 접근할 수 있다.

# using
namespace는 using 지시문을 사용해 이름공간 없이 접근할 수 있다. `using namespace std;`를 사용하면 여태 우리가 사용하던 `std::cout`을 `cout`으로 간단히 사용이 가능하다. 위의 코드에서도 `using namespace Game;`을 사용하면 간단히 `Print()`로 사용할 수 있다.

편한 만큼 주의할 점도 있다. 헤더 파일에는 사용하지 않아야 한다. 해당 헤더를 포함하는 모든 cpp 파일에도 적용이 되어버리기 때문이다. 그리고 동일한 지역 식별자가 존재하면 구분이 되지 않아 컴파일 에러가 발생한다. 

# template
데이터 형식에 의존하지 않고 하나의 값이 여러 데이터 타입을 가질 수 있게 한다. 이를 Generic Programming이라고 한다. 쉽게 말해서 수학 공식처럼 일반화를 하는 것이다. `template <typename T1, typename T2, ...>` 또는 `template <class T1, class T2, ...>` 이런 식으로 사용한다.

# explicit