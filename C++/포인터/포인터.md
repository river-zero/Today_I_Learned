- [포인터(Pointer)](#포인터pointer)
- [주소 연산자](#주소-연산자)
- [포인터 타입](#포인터-타입)
- [역참조 연산자](#역참조-연산자)
- [포인터 연산](#포인터-연산)
- [Null Pointer](#null-pointer)
- [void Pointer](#void-pointer)
- [구조체와 포인터](#구조체와-포인터)
- [const와 포인터](#const와-포인터)

# 포인터(Pointer)
객체가 있는지를 알려준다. 포인터가 강력한 도구인 이유는 참조의 의한 호출이 가능하고 복사가 필요 없어서 빠르고 메모리를 적게 먹기 때문이다. 무엇보다 동적 메모리 관리가 가능하다.

포인터 변수 자체의 크기는 32비트 환경이라면 4바이트이고 64비트 환경이라면 8바이트이다.

# 주소 연산자
주소 연산자 `&`는 단항 연산자로 오른쪽 피연산자의 주소를 가져온다.

# 포인터 타입
포인터 타입 `*`은 메모리 주소를 가리킬 수 있게 한다. 포인터는 중첩이 가능하다.

# 역참조 연산자
역참조 연산자 `*`는 단항 연산자로 오른쪽 포인터 변수가 가리키는 객체의 값에 접근한다. 

# 포인터 연산
정수를 가리키는 포인터 변수에 1을 더하는 것은 다음 정수를 가리키라는 것이므로 4바이트만큼 주소가 증가한다. 빼기도 그렇다.

# Null Pointer
`int* p{}`는 Null로 아무것도 없음을 뜻한다. C++11에서는 `nullptr`로 확실하게 구분할 수 있다. 

# void Pointer
`void` 포인터는 어떤 타입이든 가리킬 수는 있으나 역참조도 안되고 연산도 불가능하다. `(char*)p`와 같이 명시적 형변환을 하면 역참조가 가능해진다. 그러니까 `*(char *)p`가 작동한다.

# 구조체와 포인터
구조체 포인터로 멤버에 접근하려면 화살표 연산자  `->`를 사용한다. 아니면 `(*pStatus).HP`와 같이 접근할 수도 있다.

# const와 포인터
`const int* p`는 가리키는 값이 상수라서 역참조로 값을 바꿀수 없고 `int* const p`는 포인터가 상수라서 가리키는 작대기를 바꿀 수가 없다. `const int* const p`는 값도 못 바꾸고 작대기도 못 바꾼다.