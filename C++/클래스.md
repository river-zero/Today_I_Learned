# 클래스
```
class <클래스이름> [: 부모] {
[접근제한자1]:
    <멤버1>

[접근제한자2]:
    <멤버2>
    <멤버3>
} [객체이름];
```

클래스는 멤버들의 집합으로 이뤄진 데이터 형식이다. 클래스의 크기는 구조체와 마찬가지로 멤버에 따라 변한다. 그러나 멤버 함수는 영향을 주지 않는다. 패킹 정보에 따라서 8바이트나 4바이트가 사용되며 멤버 함수는 개별 처리되어 다른 함수들과 함께 특정 공간에 일괄 저장된다.

```
class Galaxy {
    // state - member variable
private:
    char modelName[10];

public:
    int color;
    int weight;

    // behaviour - member function
    void Phone() {
        modelName; // 클래스 내부에서의 사용
        std::cout << "전화 왔어요!" << std::endl;
    }

    void Message() {
        std::cout << "문자 왔어요!" << std::endl;
    }
}
```

이렇게 자료 구조와 함수를 합쳐버려 함수에서 맨날 같은 자료 구조를 넘겨줘야 하는 불편함이 사라진다.

# 접근제한자
- public

  클래스 내부/외부(인스턴스)에서 모두 사용이 가능하다. 멤버 함수는 물론이고 객체로 만든 후 객체를 통해서도 읽고 쓸 수 있다.
- protected

  자신과 자신을 기반으로 하는 파생 클래스에서 사용이 가능하다. 자신의 멤버 함수 및 파생된 멤버 함수에서 읽고 쓸 수 있다.
- private

  클래스 내부에서만 접근이 가능하고 외부(인스턴스)에서는 불가능하다. 멤버 함수에서만 해당 변수를 읽고 쓸 수 있다. 기본값으로 접근제한자를 생략하면 private으로 간주한다.

접근제한자는 중복으로 사용이 가능하다.

# 클래스와 구조체
클래스는 멤버 함수를 제외하면 구조체와 큰 차이가 없다. 구조체는 멤버 변수들만 존재하는 자료구조이고 클래스는 멤버 함수가 필요한 자료구조로 구분해도 괜찮다.

# 멤버 함수
멤버 함수도 일반 함수처럼 선언과 정의를 분리할 수 있다.

```
반환형 클래스이름::함수명(매개변수 목록) {
    return 반환값;
}
```
여기서 범위해결연산자 `::`로 멤버 함수가 어느 클래스 소속인지 명시한다. 접근제한자는 함수의 선언에 이미 존재하므로 정의에는 생략한다.

```
class Dog {
private:
    int mAge;

public:
    void Bark();
    int GetAge();
};

void Dog::Bark() {
    std::cout << "멍!" << std::endl;
}

int Dog::GetAge() {
    return mAge;
}
```

private 멤버 변수는 클래스 내부에서만 접근이 가능하므로 멤버 변수는 멤버 함수에서는 제한없이 사용할 수 있다.

일반 함수와 달리 클래스의 선언은 모든 내용이 마무리되는 세미콜론을 만나면 이뤄지므로 멤버 함수들은 서로 존재를 알고 있기 때문에 전방 선언이 필수가 아니다. 따라서 아래와 같이 사용이 가능하다.

```
class MyClass {
    void f1() {
        f2();
    }

    void f2() {
    }
};
```

# 인스턴스화
`Galaxy myPhone;`랑 같다. `myPhone.color = 1;`, `myPhone.Phone();`와 같이 사용이 가능하다. 이것이 클래스 외부에서의 사용이다.

여기서 color는 설계도인 클래스의 것이 아닌 실제 작동하는 자동차인 인스터스화한 객체 myPhone의 것이다.

# this
```
Galaxy phone1;
phone1.GetColor();
```

이런 식으로 사용하므로 함수에 매개변수를 매번 넘겨주는 귀찮은 일을 하지 않아도 된다. 애초에 어떤 인스턴스에 해당하는지 자동으로 넘어가기 때문이다. 이게 암시적 오브젝트이고 `Galaxy* this`가 생략되어 있는 것이다.

this를 사용하면 이런 암시적 오브젝트를 명시적으로 표현할 수 있다. this는 포인터이기 때문에 `->`을 사용한다.

```
int Dog::GetAge() {
    return mAge;
    // return this->mAge
}
```