- [클래스](#클래스)
- [접근제한자](#접근제한자)
- [클래스와 구조체](#클래스와-구조체)
- [멤버 함수](#멤버-함수)
- [인스턴스화](#인스턴스화)
- [this](#this)
- [캡슐화](#캡슐화)
- [정보 은닉](#정보-은닉)
- [상수(const) 멤버 함수](#상수const-멤버-함수)
- [const 정리](#const-정리)

# 클래스
```
class <클래스이름> [: 부모] {
[접근제한자1]:
    <멤버1>

[접근제한자2]:
    <멤버2>
    <멤버3>
} [객체이름];
```

클래스는 멤버들의 집합으로 이뤄진 데이터 형식이다. 클래스의 크기는 구조체와 마찬가지로 멤버에 따라 변한다. 그러나 멤버 함수는 영향을 주지 않는다. 패킹 정보에 따라서 8바이트나 4바이트가 사용되며 멤버 함수는 개별 처리되어 다른 함수들과 함께 특정 공간에 일괄 저장된다. 따라서 멤버 변수가 int 두 개라면 해당 클래스의 크기는 8바이트가 된다.

```
class Galaxy {
    // state - member variable
private:
    char modelName[10];

public:
    int color;
    int weight;

    // behaviour - member function
    void Phone() {
        modelName; // 클래스 내부에서의 사용
        std::cout << "전화 왔어요!" << std::endl;
    }

    void Message() {
        std::cout << "문자 왔어요!" << std::endl;
    }
};
```

이렇게 자료 구조와 함수를 합쳐버려 함수에서 맨날 같은 자료 구조를 넘겨줘야 하는 불편함이 사라진다.

사용자에게 노출된 기능을 인터페이스(Interface)라고 하고 이들을 내부에서 복잡한 기술로 작동시키는 것을 구현(Implementation)이라고 하는데, 인터페이스와 구현을 분리하는 것은 매우 유용하다.

# 접근제한자
- public

  클래스 내부/외부(인스턴스)에서 모두 사용이 가능하다. 멤버 함수는 물론이고 객체로 만든 후 객체를 통해서도 읽고 쓸 수 있다.
- protected

  자신과 자신을 기반으로 하는 파생 클래스에서 사용이 가능하다. 자신의 멤버 함수 및 파생된 멤버 함수에서 읽고 쓸 수 있다.
- private

  클래스 내부에서만 접근이 가능하고 외부(인스턴스)에서는 불가능하다. 멤버 함수에서만 해당 변수를 읽고 쓸 수 있다. 기본값으로 접근제한자를 생략하면 private으로 간주한다.

접근제한자는 중복으로 사용이 가능하다.

# 클래스와 구조체
클래스는 멤버 함수를 제외하면 구조체와 큰 차이가 없다. 구조체는 멤버 변수들만 존재하는 자료구조이고 클래스는 멤버 함수가 필요한 자료구조로 결론적으로 구조체는 모든 멤버가 public인 클래스이다.

# 멤버 함수
멤버 함수도 일반 함수처럼 선언과 정의를 분리할 수 있다.

```
반환형 클래스이름::함수명(매개변수 목록) {
    return 반환값;
}
```
여기서 범위 해결 연산자 `::`로 멤버 함수가 어느 클래스 소속인지 명시한다. 접근제한자는 함수의 선언에 이미 존재하므로 정의에는 생략한다.

```
class Dog {
private:
    int mAge;

public:
    void Bark();
    int GetAge();
};

void Dog::Bark() {
    std::cout << "멍!" << std::endl;
}

int Dog::GetAge() {
    return mAge;
}
```

private 멤버 변수는 클래스 내부에서만 접근이 가능하므로 멤버 변수는 멤버 함수에서는 제한없이 사용할 수 있다.

일반 함수와 달리 클래스의 선언은 모든 내용이 마무리되는 세미콜론을 만나면 이뤄지므로 멤버 함수들은 서로 존재를 알고 있기 때문에 전방 선언이 필수가 아니다. 따라서 아래와 같이 사용이 가능하다.

```
class MyClass {
    void f1() {
        f2();
    }

    void f2() {
    }
};
```

# 인스턴스화
`Galaxy myPhone;`랑 같다. `myPhone.color = 1;`, `myPhone.Phone();`와 같이 사용이 가능하다. 이것이 클래스 외부에서의 사용이다.

여기서 `color`는 설계도인 클래스의 것이 아닌 실제 작동하는 자동차인 인스터스화한 객체 `myPhone`의 것이다.

# this
```
Galaxy phone1;
phone1.GetColor();
```

이런 식으로 사용하므로 함수에 매개변수를 매번 넘겨주는 귀찮은 일을 하지 않아도 된다. 애초에 어떤 인스턴스에 해당하는지 자동으로 넘어가기 때문이다. 이게 암시적 오브젝트이고 `Galaxy* this`가 생략되어 있는 것이다.

`this`를 사용하면 이런 암시적 오브젝트를 명시적으로 표현할 수 있다. `this`는 포인터이기 때문에 `->`을 사용한다.

```
int Dog::GetAge() {
    return mAge;
    // return this->mAge
}
```

# 캡슐화
객체를 특정짓는 상태와 행동을 하나로 묶어서 관리하는 것이다. 외부에서 볼 때 하나의 캡슐만 파악하면 되고 내부의 상태나 행동은 몰라도 되므로 명료한 프로그램 작성이 가능하다.

```
class Dog {
public:
    enum Color {
        WHITE = 0xFFFFFFFF,
        BLACK = 0xFF000000,
    };

private:
    class Toy {
        char mName[8];
    };
};
```

이런 식으로 다른 클래스나 구조체를 내부에 선언하거나 열거형과 같은 타입의 정의도 내부에 포함시킬 수 있다.

```
int main() {
    Dog::Color myColor = Dog::Color::WHITE;
}
```

이때, 클래스 내부의 public 형식을 외부에서 사용하려면 범위 해결 연산자 `::`을 사용하면 된다. 

```
class Cat {
public:
    enum Color {
        WHITE = 0xFFEEEEEE,
        BLACK = 0xFF000000
    };
};
```

만약 위와 같이 고양이 클래스를 하나 만들어서 동일한 이름을 가진 Color 열거형이 또 있어도 다음과 같이 사용이 가능하다. 이는 클래스 내부에 선언함으로 인해서 가능한 일이다.

```
Dog::Color myColor1 = Dog::Color::WHITE;
Cat::Color myColor2 = Cat::Color::WHITE;
```

# 정보 은닉
캡슐화를 사용해 외부에 불필요하거나 보안이 필요한 정부들을 숨길 수 있는데, 이를 정보 은닉이라 한다. 클래스의 멤버들도 숨겨두는 것이 안전한 경우가 많다.

```
#include <iostream>

class Inventory {
private:
    std::string items[10];

public: 
    std::string GetItem(int index) {
        if (index < 0 || index >= 10) {
            return "Invalid";
        }

        return items[index];
    }
};

int main() {
    Inventory inv;

    std::cout << inv.GetItem(20);
}
```

이런 식으로 `items`를 숨기고 입력값이 안전한지 확인하고 반환하는 인터페이스를 제공하면 프로그램의 안정성도 높아진다. 데이터의 정확성과 일관성을 유지하는 것을 무결성이라고 하며 이것이 버그 없는 게임 제작의 핵심이다.

# 상수(const) 멤버 함수
`반환형 함수이름(매개변수) const;` 이런 식으로 사용한다. 이러면 멤버 함수는 상수 함수가 되고 함수 내부에서 클래스의 멤버의 어떠한 값도 변경하지 않는다는 뜻이다.

다른 OOP 언어들에는 속성(Property)라고 불리는 개념이 존재한다. 멤버 변수로의 접근을 막고 멤버 함수로 접근하게 하는 것이 목적인데 이를 C++에서 흉내낼 수 있게 해준다. 이것을 Getter(값 구해오기)/Setter(값 지정하기)라고 한다.

```
class Calendar {
private:
    int mMonth;

public:
    void SetMonth (std::string month) {
        // 문자열을 판단해서 month에 값을 지정
    }

    std::string GetMonth() const {
        // month에 따라 문자열 반환
    }
};
```

위와 같이 주로 Getter에서 const 멤버 함수를 사용한다.

# const 정리
|       사용        |                                  설명                                  |                 예시                  |
| :---------------: | :--------------------------------------------------------------------: | :-----------------------------------: |
|    const 변수     |                  값을 변경할 수 없는 상수 변수로 사용                  |     `const int NAME_LENGTH = 10;`     |
|  const 매개변수   |      함수 내부에서 매개변수의 값을 변경하지 않는다는 의미로 사용       | `void PrintInfo(const Stack& stack);` |
| const 반환형 함수 | 반환형에 참조형이 사용될 때 해당 반환값을 변경할 수 없다는 의미로 사용 |      `const Stack& GetStack();`       |
|  const 멤버함수   |    멤버함수 내부에서 맴버변수의 값을 수정하지 않는다는 의미로 사용     |        `int GetCount() const;`        |

|          사용          |                                 설명                                 |
| :--------------------: | :------------------------------------------------------------------: |
|    `const int* p1;`    |             `*p1 = 5;`와 같은 식으로 값을 변경할 수 없음             |
|    `int* const p2;`    |  `p2 = &x;`와 같이 포인터 `p2`가 다른 것을 가리키게 변경할 수 없음   |
| `const int* const p3;` | `p3`가 가리키는 값 변경도 `p3`가 다른 것을 가리키도록 변경할 수 없음 |

const를 필요한 곳에 적절하게 사용하면 훨씬 더 의미있는 코딩이 가능하다.