- [클래스](#클래스)
- [접근제한자](#접근제한자)
- [클래스와 구조체](#클래스와-구조체)
- [멤버 함수](#멤버-함수)
- [인스턴스](#인스턴스)
- [this](#this)
- [캡슐화](#캡슐화)
- [정보 은닉](#정보-은닉)
- [상수(const) 멤버 함수](#상수const-멤버-함수)
- [const 정리](#const-정리)
- [생성자(constructor)](#생성자constructor)
- [소멸자(destructor)](#소멸자destructor)
- [암시적 생성자](#암시적-생성자)
- [기본 생성자](#기본-생성자)
- [생성자와 소멸자 호출 순서](#생성자와-소멸자-호출-순서)
- [생성자의 오버로딩](#생성자의-오버로딩)
- [초기화 종류](#초기화-종류)
- [멤버 초기화 리스트(member initializer list)](#멤버-초기화-리스트member-initializer-list)
- [대리 생성자](#대리-생성자)
- [default 키워드](#default-키워드)
- [상수 클래스(const class)](#상수-클래스const-class)

# 클래스
```
class <클래스이름> [: 부모] {
[접근제한자1]:
    <멤버1>

[접근제한자2]:
    <멤버2>
    <멤버3>
} [객체이름];
```

클래스는 멤버들의 집합으로 이뤄진 데이터 형식이다. 클래스의 크기는 구조체와 마찬가지로 멤버에 따라 변한다. 그러나 멤버 함수는 영향을 주지 않는다. 패킹 정보에 따라서 8바이트나 4바이트가 사용되며 멤버 함수는 개별 처리되어 다른 함수들과 함께 특정 공간에 일괄 저장된다. 따라서 멤버 변수가 int 두 개라면 해당 클래스의 크기는 8바이트가 된다.

클래스 내에 클래스를 중첩해 사용할 수도 있으나 이는 접근제한자에 영향을 받으므로 주의해야 한다. 

```
class Galaxy {
    // state - member variable
private:
    char modelName[10];

public:
    int color;
    int weight;

    // behaviour - member function
    void Phone() {
        modelName; // 클래스 내부에서의 사용
        std::cout << "전화 왔어요!" << std::endl;
    }

    void Message() {
        std::cout << "문자 왔어요!" << std::endl;
    }
};
```

이렇게 자료 구조와 함수를 합쳐버려 함수에서 맨날 같은 자료 구조를 넘겨줘야 하는 불편함이 사라진다.

사용자에게 노출된 기능을 인터페이스(Interface)라고 하고 이들을 내부에서 복잡한 기술로 작동시키는 것을 구현(Implementation)이라고 하는데, 인터페이스와 구현을 분리하는 것은 매우 유용하다.

# 접근제한자
- public

  클래스 내부/외부(인스턴스)에서 모두 사용이 가능하다. 멤버 함수는 물론이고 객체로 만든 후 객체를 통해서도 읽고 쓸 수 있다.
- protected

  자신과 자신을 기반으로 하는 파생 클래스에서 사용이 가능하다. 자신의 멤버 함수 및 파생된 멤버 함수에서 읽고 쓸 수 있다.
- private

  클래스 내부에서만 접근이 가능하고 외부(인스턴스)에서는 불가능하다. 멤버 함수에서만 해당 변수를 읽고 쓸 수 있다. 기본값으로 접근제한자를 생략하면 private으로 간주한다.

접근제한자는 중복으로 사용이 가능하다.

# 클래스와 구조체
클래스는 멤버 함수를 제외하면 구조체와 큰 차이가 없다. 구조체는 멤버 변수들만 존재하는 자료구조이고 클래스는 멤버 함수가 필요한 자료구조로 결론적으로 구조체는 모든 멤버가 public인 클래스이다.

# 멤버 함수
멤버 함수도 일반 함수처럼 선언과 정의를 분리할 수 있다.

```
반환형 클래스이름::함수명(매개변수 목록) {
    return 반환값;
}
```
여기서 범위 해결 연산자 `::`로 멤버 함수가 어느 클래스 소속인지 명시한다. 접근제한자는 함수의 선언에 이미 존재하므로 정의에는 생략한다.

```
class Dog {
private:
    int mAge;

public:
    void Bark();
    int GetAge();
};

void Dog::Bark() {
    std::cout << "멍!" << std::endl;
}

int Dog::GetAge() {
    return mAge;
}
```

private 멤버 변수는 클래스 내부에서만 접근이 가능하므로 멤버 변수는 멤버 함수에서는 제한없이 사용할 수 있다.

일반 함수와 달리 클래스의 선언은 모든 내용이 마무리되는 세미콜론을 만나면 이뤄지므로 멤버 함수들은 서로 존재를 알고 있기 때문에 전방 선언이 필수가 아니다. 따라서 아래와 같이 사용이 가능하다.

```
class MyClass {
    void f1() {
        f2();
    }

    void f2() {
    }
};
```

# 인스턴스
`Galaxy myPhone;`랑 같다. `myPhone.color = 1;`, `myPhone.Phone();`와 같이 사용이 가능하다. 이것이 클래스 외부에서의 사용이다.

여기서 `color`는 설계도인 클래스의 것이 아닌 실제 작동하는 자동차인 인스터스화한 객체 `myPhone`의 것이다.

# this
```
Galaxy phone1;
phone1.GetColor();
```

이런 식으로 사용하므로 함수에 매개변수를 매번 넘겨주는 귀찮은 일을 하지 않아도 된다. 애초에 어떤 인스턴스에 해당하는지 자동으로 넘어가기 때문이다. 이게 암시적 오브젝트이고 `Galaxy* this`가 생략되어 있는 것이다.

`this`를 사용하면 이런 암시적 오브젝트를 명시적으로 표현할 수 있다. `this`는 포인터이기 때문에 `->`을 사용한다.

```
int Dog::GetAge() {
    return mAge;
    // return this->mAge
}
```

# 캡슐화
객체를 특정짓는 상태와 행동을 하나로 묶어서 관리하는 것이다. 외부에서 볼 때 하나의 캡슐만 파악하면 되고 내부의 상태나 행동은 몰라도 되므로 명료한 프로그램 작성이 가능하다.

```
class Dog {
public:
    enum Color {
        WHITE = 0xFFFFFFFF,
        BLACK = 0xFF000000,
    };

private:
    class Toy {
        char mName[8];
    };
};
```

이런 식으로 다른 클래스나 구조체를 내부에 선언하거나 열거형과 같은 타입의 정의도 내부에 포함시킬 수 있다.

```
int main() {
    Dog::Color myColor = Dog::Color::WHITE;
}
```

이때, 클래스 내부의 public 형식을 외부에서 사용하려면 범위 해결 연산자 `::`을 사용하면 된다. 

```
class Cat {
public:
    enum Color {
        WHITE = 0xFFEEEEEE,
        BLACK = 0xFF000000
    };
};
```

만약 위와 같이 고양이 클래스를 하나 만들어서 동일한 이름을 가진 Color 열거형이 또 있어도 다음과 같이 사용이 가능하다. 이는 클래스 내부에 선언함으로 인해서 가능한 일이다.

```
Dog::Color myColor1 = Dog::Color::WHITE;
Cat::Color myColor2 = Cat::Color::WHITE;
```

# 정보 은닉
캡슐화를 사용해 외부에 불필요하거나 보안이 필요한 정부들을 숨길 수 있는데, 이를 정보 은닉이라 한다. 클래스의 멤버들도 숨겨두는 것이 안전한 경우가 많다.

```
#include <iostream>

class Inventory {
private:
    std::string items[10];

public: 
    std::string GetItem(int index) {
        if (index < 0 || index >= 10) {
            return "Invalid";
        }

        return items[index];
    }
};

int main() {
    Inventory inv;

    std::cout << inv.GetItem(20);
}
```

이런 식으로 `items`를 숨기고 입력값이 안전한지 확인하고 반환하는 인터페이스를 제공하면 프로그램의 안정성도 높아진다. 데이터의 정확성과 일관성을 유지하는 것을 무결성이라고 하며 이것이 버그 없는 게임 제작의 핵심이다.

# 상수(const) 멤버 함수
`반환형 함수이름(매개변수) const;` 이런 식으로 사용한다. 이러면 멤버 함수는 상수 함수가 되고 함수 내부에서 클래스의 멤버의 어떠한 값도 변경하지 않는다는 뜻이다.

다른 OOP 언어들에는 속성(Property)라고 불리는 개념이 존재한다. 멤버 변수로의 접근을 막고 멤버 함수로 접근하게 하는 것이 목적인데 이를 C++에서 흉내낼 수 있게 해준다. 이것을 Getter(값 구해오기)/Setter(값 지정하기)라고 한다.

```
class Calendar {
private:
    int mMonth;

public:
    void SetMonth (std::string month) {
        // 문자열을 판단해서 month에 값을 지정
    }

    std::string GetMonth() const {
        // month에 따라 문자열 반환
    }
};
```

위와 같이 주로 Getter에서 const 멤버 함수를 사용한다.

# const 정리
|       사용        |                                  설명                                  |                 예시                  |
| :---------------: | :--------------------------------------------------------------------: | :-----------------------------------: |
|    const 변수     |                  값을 변경할 수 없는 상수 변수로 사용                  |     `const int NAME_LENGTH = 10;`     |
|  const 매개변수   |      함수 내부에서 매개변수의 값을 변경하지 않는다는 의미로 사용       | `void PrintInfo(const Stack& stack);` |
| const 반환형 함수 | 반환형에 참조형이 사용될 때 해당 반환값을 변경할 수 없다는 의미로 사용 |      `const Stack& GetStack();`       |
|  const 멤버함수   |    멤버함수 내부에서 맴버변수의 값을 수정하지 않는다는 의미로 사용     |        `int GetCount() const;`        |

|          사용          |                                 설명                                 |
| :--------------------: | :------------------------------------------------------------------: |
|    `const int* p1;`    |             `*p1 = 5;`와 같은 식으로 값을 변경할 수 없음             |
|    `int* const p2;`    |  `p2 = &x;`와 같이 포인터 `p2`가 다른 것을 가리키게 변경할 수 없음   |
| `const int* const p3;` | `p3`가 가리키는 값 변경도 `p3`가 다른 것을 가리키도록 변경할 수 없음 |

const를 필요한 곳에 적절하게 사용하면 훨씬 더 의미있는 코딩이 가능하다.

# 생성자(constructor)
여기서 생성자는 객체가 인스턴스화할 때 자동으로 호출되는 특별한 멤버 함수다. 클래스와 동일한 이름을 가지며 반환 타입이 없다. 이때는 void도 사용하지 않는다. 

생성자는 크게 멤버 변수를 기본값 또는 사용자가 넘겨준 값으로 초기화할 떄, 자료구조를 준비하거나 사용할 데이터 파일을 불러오는 등의 내부 작업에 사용된다. 이는 private 멤버 변수도 초기화할 수 있어 매우 유용하다.

# 소멸자(destructor)
인스턴스가 소멸할 때 자동으로 호출되는 특별한 멤버 함수다. 클래스와 동일한 이름을 가지며 매개 변수도 반환 타입도 없다. 역시 void도 사용하지 않는다. 접두어 `~`로 생성자와 구별된다.

```
#include <iostream>

class MyArray {
private:
    int* mArray;
    int mLength;

public:
    MyArray(int len) : mLength{ len }, mArray{ new int[len] } {
        // mArray = new int [len] {};
    }

    ~MyArray() {
        delete[] mArray;
        // 동적 할당한 배열을 이런 식으로 손쉽게 해제 가능
    }
};

int main() {
    MyArray array{ 100 };
}
```

# 암시적 생성자
생성자나 소멸자를 제공하지 않으면 컴파일러가 자동으로 아무것도 하지 않는 빈 기본 생성자와 소멸자를 붙여준다. 이것을 암시적 생성자라고 한다. 

# 기본 생성자 
매개변수가 없는 생성자를 말한다. 대개 멤버들을 기본값으로 초기화하기 위해 사용한다.

```
#include <iostream>

class Monster {
private:
    int mHealth;
    int mLevel;

public:
    Monster() {
        mHealth = 1;
        mLevel  = 1;
    }

    void Print() {
        std::cout << "Health : " << mHealth << std::endl;
        std::cout << "Level : " << mLevel << std::endl;
    }
};

int main() {
    Monster m1;
    m1.Print();
}

```

물론 기본 생성자 외에도 함수처럼 매개변수를 받는 생성자를 만들 수도 있다.

```
#include <iostream>

class Monster {
private:
    int mHealth{ 1 };
    int mLevel{ 1 };

public:
    Monster(int level, int health) {
        mLevel  = level;
        mHealth = health;
    }

    void Print() {
        std::cout << mHealth << ", " << mLevel << std::endl;
    }
};

int main() {
    Monster m1(10, 100);
    m1. Print();
}
```

이는 인스턴스를 생성자를 통해 초기화하는 방법이다. 결과값은 `1, 1`이 아닌 `10, 100`이 됨을 알 수 있다.

# 생성자와 소멸자 호출 순서
```
class ClassA {
public:
    ClassA() {
        std::cout << "ClassA의 생성자 호출" << std::endl;
    }

    ~ClassA() {
        std::cout << "ClassA의 소멸자 호출" << std::endl;
    }
};

class ClassB {
private:
    ClassA objA;

public:
    ClassB() {
        std::cout << "ClassB의 생성자 호출" << std::endl;
    }

    ~ClassB() {
        std::cout << "ClassB의 소멸자 호출" << std::endl;
    }
};

int main() {
    ClassB objB;
}
```

위 코드에서의 결과는 다음과 같다. 동적 할당한 2차원 배열을 해제하는 경우와 마찬가지로 소멸은 생성의 역순임을 알 수 있다.

```
ClassA의 생성자 호출
ClassB의 생성자 호출
ClassB의 소멸자 호출
ClassA의 소멸자 호출
```

# 생성자의 오버로딩
생성자도 오버로딩이 가능하다. 주의할 점은 이때 컴파일러의 특성상 함수의 선언으로 간주하므로 기본 생성자는 괄호 없이 `Monster m1`으로 사용해야 한다. 혹은 유티폼 초기화식을 사용해 `Monster m1{}`, `Monster m1{ 1,10 }`와 같이 사용할 수 있다. 이때 유니폼 초기화식은 항상 생성자를 우선적으로 작동한다.

당연하게도 매개변수에서 초기화도 가능하다. 이를 이용하면 남발되는 생성자의 개수를 줄일 수 있다.

# 초기화 종류
- `Monster m1 = Monster(2);` : 복사 초기화(copy initialization)
-  `Monster m2(10, 100);` : 직접 초기화(direct initialization)
-  `Monster m3{ 10,100 };` : 유니폼 초기화(uniform initalization)
-  `Monster m4 = { 10,100 };` : 유니폼 복사 초기화(uniform copy initialzation)
   -  `Monster m4 = Monster{ 10,100 };`와 동일하다.

직접 초기화와 유니폼 초기화 방식이 복사가 없는 작업으로 더 효율적이다. 어떤 방식을 사용하더라도 생성자는 한 번 호출된다. 이는 비주얼 스튜디오에서 최적화를 해주기 때문이다.

# 멤버 초기화 리스트(member initializer list)
상수 변수를 초기화식 외에서도 값을 바꿀 수 있게 해준다. 선언과 정의를 분리한다면 멤버 초기화 리스트는 선언이 아닌 정의에 포함되어야 한다. 이를 잘 활용하면 멤버를 초기화하기 위해 추가적으로 생성자를 만들 필요가 없다.

```
Monster(int level = 0, int health = 0) : mHealth{ level }, mLevel{ health } {
   // 멤버 초기화 리스트를 먼저 실행하고 이곳을 실행
   // mHealth{ level }는 mHealth( level )과 동일
}
```

# 대리 생성자
```
Quest() : mid{ 1 }, mExp{ 1 } {
    // 1 : 기본 퀘스트 초기화
}

Quest(std::string excel) : Quest{} {
    // 1의 작업을 위의 Quest{}를 불러 대신한다.
    // 2 : 엑셀에서 퀘스트 정보 가져온 후
}
```

위임 생성자라고도 한다. 동일한 기능을 사용하는 생성자에 중복 코드를 방지하기 위해 사용한다. 어쨌든 객체는 하나이므로 소멸자는 한 번만 호출된다. 단점이라면 `:` 기호를 사용하기 때문에 대리 생성자 또는 멤버 초기화 리스트 둘 중에 하나만 사용해야 한다는 점이다.

# default 키워드
C++ 11 이전 버전에서는 매개변수가 있는 생성자를 사용해야 할 때 기본 생성자 `MyClass() {}`도 무조건 정의해 주어야 했다. 하지만 인터페이스 클래스라면 구현부를 노출해서는 안되기 때문에 이는 바람직하지 않다. 그렇다면 `MyClass();`로 선언만 남기고 따로 `MyClass::MyClass() {}`와 같이 구현해주어야 하는데 여간 거추장스러운 것이 아니다. 

```
class MyClass {
public:
    MyClass() = default;
    MyClass(int i);
};
```

이 때문에 C++ 11 표준부터는 명시적인 디폴트 생성자라는 개념이 생겼다. 위 코드에서처럼 `MyClass() = default;`를 사용하면 구현부 없이도 기본 생성자를 간편하게 선언할 수 있다.

# 상수 클래스(const class)
```
#include <iostream>

class MyClass {
public:
    int mValue1;
    int mValue2;

    MyClass() : MyClass(1, 1) {}
    MyClass(int v1, int v2) : mValue1(v1), mValue2(v2) {}

    void Change(int x, int y) {
        mValue1 = x;
        mValue2 = y;
    }

    void Print() const { // 만약 const가 없다면 상수 클래스라 접근 불가
        std::cout << mValue1 << ", " << mValue2 << std::endl;
    }
};

int main() {
    const MyClass c1{ 2, 2 };
    // const MyClass c1{ 2 };의 경우 생성자와 매치되지 않아 동작하지 않음
    // 유니폼 초기화는 생성자 우선이기 때문

    // c1.mValue1 = 1;
    // 상수 클래스라서 값 변경 불가

    c1.Print();
}
```