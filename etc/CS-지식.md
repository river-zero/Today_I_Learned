- [컴퓨터 기초](#컴퓨터-기초)
- [CPU](#cpu)
- [Memory](#memory)
- [프로그래밍 언어](#프로그래밍-언어)
- [C, C#, C++](#c-c-c)
- [2의 보수](#2의-보수)
- [정적 라이브러리와 동적 라이브러리](#정적-라이브러리와-동적-라이브러리)
- [POD(Plain Old Data)](#podplain-old-data)
- [무명 객체(Anonymous Object)](#무명-객체anonymous-object)
- [Relationship](#relationship)
- [멀티태스킹](#멀티태스킹)
- [프로세스](#프로세스)
- [컨텍스트 스위칭](#컨텍스트-스위칭)
- [스레드](#스레드)
- [교착상태(deadlock)](#교착상태deadlock)
- [상호 배제(mutual exclusion)](#상호-배제mutual-exclusion)
- [임계 구역(ciritical section)](#임계-구역ciritical-section)
- [바이트 순서(Byte Order)](#바이트-순서byte-order)
- [문자 집합(Character Set)](#문자-집합character-set)
- [인코딩(Encoding)](#인코딩encoding)
- [UTF(Unicode Transformation Format)](#utfunicode-transformation-format)
- [랜덤](#랜덤)
- [설계 방식](#설계-방식)
- [캐시](#캐시)
- [CPU 파이프라인](#cpu-파이프라인)
- [SIMD(Single Instruction Multiple Data)](#simdsingle-instruction-multiple-data)
- [호출 규칙](#호출-규칙)
- [Register Type vs Memory Type](#register-type-vs-memory-type)

# 컴퓨터 기초
컴퓨터는 껐다 키는 스위치에서 출발한다. 컴퓨터가 0과 1로 이루어졌다고 하는 이유도 여기에 있다.

최초의 컴퓨터라고 하는 에니악만 해도 크기가 운동장만하다. 진공관 ⊂ 트랜지스터 ⊂ 집적회로(IC)로 발전하면서 이 모든걸 압축한게 지금의 컴퓨터로, 결국 컴퓨터의 역사는 집적의 역사라고 할 수 있다.

# CPU
컴퓨터의 핵심이다. Central Processing Unit(중앙처리장치)를 줄여서 부른다.

CPU는 연산, 제어, 기억 이렇게 세 가지 요소를 담당하고 있다.

CPU는 레지스터라고 하는 아주 빠른 저장 공간을 쓴다. 마구잡이로 명령들을 처리하면 안되니까 이 명령들을 나열해서 기억할 공간이 필요한 것이다. 이 레지스터 크기에 따라서 32비트 컴퓨터냐 64비트 컴퓨터냐 하는 것이 정해진다. 어떤 프로그램을 설치할 때 x86인지 x64인지로 나뉘는 이유기도 하다.

# Memory
ROM(Read Only Memory)이니 RAM(Random Access Memory)이니 하는 것들이다.

레지스터로는 크기가 작으니까 밖에 더 저장할 수 있는 공간을 만들었다.

ROM은 이름에서 알 수 있듯이 오로지 읽기만 한다. 컴퓨터를 구동할 때 필요한 정보가 들어있어서 전원을 꺼도 정보가 그대로 있다. RAM은 우리가 흔히 컴퓨터 조립이나 업그레이드할 때 부르는 그 램이 맞다.

# 프로그래밍 언어
0과 1로 이뤄져서 컴퓨터가 바로 알아듣는 언어가 기계어다. 이걸 사람이 쓰기엔 너무 불편해서 그래도 최소한 의미가 있는 걸로 바꾼게 어셈블리어다. 두 언어 모두 저수준 언어로 컴퓨터친화적이라고 볼 수 있다.

여기서 더 나아가서 만든게 고수준 언어로 우리가 많이 쓰는 C, C++, Java와 같은 언어가 여기에 속한다. 인간친화적인 언어라서 중간에 통역이 필요하다.

# C, C#, C++
| 언어  |                  장점                   |                     단점                      |
| :---: | :-------------------------------------: | :-------------------------------------------: |
|   C   |         하드웨어에 가까운 접근          |   메모리 관리 및 보안에 대한 직접적인 책임    |
|       |                 이식성                  | 낮은 수준의 추상화로 개발 속도가 느릴 수 있음 |
|       |   오래된 레거시 코드와의 통합에 유리    |      코드 복잡성 증가로 인한 버그 가능성      |
|  C#   |         Unity 게임 개발에 적합          |      성능 면에서 C++보다 떨어질 수 있음       |
|       | 높은 수준의 추상화를 제공하여 빠른 개발 |  특정 플랫폼에 종속되는 경우가 있을 수 있음   |
|  C++  |         뛰어난 성능 최적화 가능         |   메모리 관리와 보안 문제에 대한 책임 부담    |
|       |    하드웨어 리소스에 직접 접근 가능     | 높은 복잡성으로 인해 개발 속도가 느릴 수 있음 |
|       |         크로스 플랫폼 개발 가능         |     초보자에게는 학습 곡선이 높을 수 있음     |
|       |         게임 엔진과의 통합 용이         |  예외 처리와 메모리 관리 등이 복잡할 수 있음  |

# 2의 보수
컴퓨터는 양수와 음수를 구분하기 위해서 가장 앞의 비트를 사용한다. 그리고 음수를 더하기로 계산하기 위해서 2의 보수를 사용한다. `0101`의 2의 보수는 비트를 반전시키고 1을 더한 `1011`이 되는 식이다.

# 정적 라이브러리와 동적 라이브러리
|                           정적 라이브러리                           |                       동적 라이브러리                        |
| :-----------------------------------------------------------------: | :----------------------------------------------------------: |
|                              lib 파일                               |                           dll 파일                           |
|                         실행파일만으로 실행                         |             실행파일과 별도의 dll을 이용해 실행              |
|               외부 정보를 참조하지 않기 때문에 빠르다               |         실행 시간에 dll 파일을 뒤져야 하므로 느리다          |
|                 라이브러리 기능을 수정하기가 어렵다                 |            라이브러리를 쉽게 업그레이드 가능하다             |
| 서로 다른 프로젝트에서 사용하려면 각각 라이브러리를 링크해야만 한다 | 서로 다른 프로젝트에서도 하나의 dll만 있으면 사용이 가능하다 |

동적 라이브러리는 기능이 변경되어도 다시 빌드할 필요 없이 간단히 라이브러리만 배포하면 된다.

# POD(Plain Old Data)
C언어에서 제공되는 타입들이 여기에 해당하는데 단순한 메로리 구조를 가지는 객체를 뜻한다. 원본 메모리에서 다른 메모리로 복사나 이동이 매우 쉬워 컴퓨터 성능에 유리하다는 장점이 있다.

C++에서 POD는 Standard Layout Type, Trivial Type 이렇게 두 가지 조건이 충족되어야 한다고 본다. 이는 성능에 관련이 있는데 사용자가 클래스에 생성자를 붙이면 Trivial Type이 아니게 된다.

```
#include <iostream>

class ClassA {
public:
    ClassA() {}
};

class ClassB {
public:
    ClassB() = default;
};

int main() {
    std::cout << std::is_trivial<ClassA>::vlaue << std::is_pod<ClassA>::value <<std::endl;

     std::cout << std::is_trivial<ClassB>::vlaue << std::is_pod<ClassB>::value <<std::endl;
}
```

위 코드를 출력해보면 ClassA는 Trivial Type, POD가 아니고 ClassB는 Trivial Type, POD가 맞다는 결과를 알 수 있다. 그러니까 POD가 되기 위해서는 default 키워드로 암시적 기본 생성자를 명시해야 한다.

# 무명 객체(Anonymous Object)
이름이 없는 임시 객체로 주로 한 번만 사용되거나 함수의 반환값, 특정 표현식의 결과로 생성되는 객체로 rvalue를 가리킨다.

```
class MyClass {
public:
    int mValue;
    MyClass(int value) : mValue(value) {
        std::cout << "[ MyClass() ] : " << mValue << std::endl;
    }

    MyClass operator+(const MyClass& c) {
        return MyClass{ mValue + c.mValue };
    }
};

int Square(MyClass c) {
    return c.mValue * c.mValue;
}

int main() {
    MyClass c1{ 1 }, c2 { 2 };

    std::cout << "-----" << std::endl;
    Square(c1 + c2);

    std::cout << "-----" << std::endl;
    std::cout << (c1 + c2).mValue << std::endl;

    std::cout << "-----" << std::endl;
    MyClass c3{ c1 + c2 };
}
```

위 코드의 출력은 아래와 같다. c1, c2를 생성할 때 외에도 3번 생성자가 불리는 것을 알 수 있는데, 이들이 무명객체이다.

```
[ MyClass() ] : 1
[ MyClass() ] : 2
-----
[ MyClass() ] : 3
-----
[ MyClass() ] : 3
3
-----
[ MyClass() ] : 3
```

조금 더 효율적인 프로그램을 만들기 위해 Square 함수에 매개변수를 참조형인 `MyClass& c`로 받는다면 오류가 발생한다. 무명객체는 rvalue이기 때문에 당연히 참조형을 사용할 수 없다. 따라서 `const MyClass& c`로 사용하면 오류가 발생하지 않는다.

# Relationship
|    용어    |                        개념                        |
| :--------: | :------------------------------------------------: |
| is-part-of |                 Composition(결합)                  |
|   has-a    |                Aggregation(집단화)                 |
|   use-a    |                Association(연관화)                 |
|    is-a    | Generalization(일반화) 또는 Specialication(특수화) |

A is-part-of B 관계는 예를 들면 엔진 is-part-of 자동차라고 할 수 있다.
- A는 B의 일부 구성 요소이다.
- A는 한 번에 하나의 객체에만 존재한다.
- A는 B에 의해 관리된다.
- A는 B의 존재를 알지 못한다.

```
class Status {
public:
    int mHP;
    int mMP;
};

class Player {
    Status mStatus;
};
```

위 코드에서 A는 Status에 해당하고 B는 Player에 해당함을 알 수 있다.

A has-a B 관계는 예를 들면 자동차 has-a 타이어라고 할 수 있다.
- B는 A의 일부 구성 요소이다.
- B는 한 번에 여러 오브젝트에 소속된다.
- B는 A에 의해 관리되지 않는다.
- B는 A의 존재를 알지 못한다.

```
class Player {
};

class Auction {
    Player* mPlayers;
};
```

위 코드에서 A는 Auction에 해당하고 B는 Player에 해당한다.

A use-a B 관계는 예를 들면 운전자 use-a 자동차라고 할 수 있다.
- B는 A와 관련이 없다.
- B는 한 번에 여러 오브젝트에 소속된다.
- B가 A에 의해 관리되지 않는다. 
- B는 A의 존재를 알 수도 있고 모를 수도 있다.

```
class Potion {
public:
    int mCount;
    int mRecovery;
};

class Player {
    Potion* pPotion;
};
```

위 코드에서 A는 Plyaer에 해당하고 B는 Potion에 해당한다.

A is-a B 관계는 예를 들면 경찰차 is-a 자동차라고 할 수 있다. 핵심은 공통된 개념을 묶어서 일반화하는 것과 여기서 추가 정보를 포함하여 객체를 생성하는 특수화이다. 그러니까 파생, 다른 말로는 상속을 말한다.

# 멀티태스킹
DOS 시스템을 거쳐 GUI 시스템으로 변화하면서 프로그램이 여러 개 화면에 동시에 실행되는 기술이 필요해졌다. 이렇게 여러 작업을 실행하는 것을 멀티태스킹이라고 한다. 

그러나 컴퓨터는 기본적으로 주어진 입력을 계산하여 출력하는 순차 작업으로 병렬적인 작업을 흉내내기 위해서 급한 작업이 요청되면 가장 앞으로 빼서 우선 처리하는 방식으로 진행된다. 다만 이런 처리가 아주 빠르게 진행되기 때문에 보기에는 동시에 프로그램이 실행되는 것처럼 보이는 것이다. 이러한 것을 스케줄링이라고 한다.

# 프로세스
운영체제의 작업 단위로 컴퓨터에서 실행 중인 프로그램을 나타내는 개념이다. 좀 더 구체적으로 프로세스는 메모리에 적재되어 실행 중인 프로그램의 인스턴스를 의미한다.

# 컨텍스트 스위칭
프로세스는 사용자의 입력에 따라서 휴면/활성 상태가 된다. 이런 상태 변화를 위해서는 각 프로세스의 현재 진행 상태를 저장했다가 복원해야 한다. 이러한 것을 컨텍스트라고 부르고 작업 전환이 일어나면 현재 프로세스와 이전 프로세스의 컨텍스트를 교체해주는 방식으로 진행된다. 이를 컨텍스트 스위칭이라 한다.

# 스레드
하나의 프로세스에서도 당연히 동시에 처리할 필요가 있다. 이러한 것을 스레드라고 한다. 스레드 역시 엄밀히 말하면 동시가 아닌 스케줄링이다. 기본적으로 프로세스의 자원을 공유하는 방식으로 컴텍스트 스위칭과 같은 오버헤드는 없지만 공유하는 데이터를 여러 스레드가 동시에 접근하기 때문에 다양한 문제가 발생한다.

|                 프로세스                 |                  스레드                   |
| :--------------------------------------: | :---------------------------------------: |
| 프로그램이 실행되어 메모리에 등록된 상태 | 한 프로세스에서 실행되는 여러 흐름의 단위 |
|      자신의 정보를 컨텍스트에 저장       |       프로세스의 공유 메모리에 접근       |
|             운영체제가 제어              |              프로세스가 제어              |
|           컨텍스트 스위칭 문제           |                데드락 문제                |

# 교착상태(deadlock)
멀티 스레드 또는 멀티 프로세스 환경에서 발생하는 문제로, 같은 사다리에 두 사람이 이미 올라타서 눈치게임을 하는 상황과 같다. 모든 작업이 멈추게 되어 시스템이 더 이상 진행하지 못하는 상태를 일으킬 수 있다. 안타깝게도 현재까지 이를 해결하는 방법은 없다 오로지 예방만 가능하다.

# 상호 배제(mutual exclusion)
여러 개의 스레드나 프로세스가 공유하는 자원에 동시에 접근하는 것을 방지한다. 사다리를 임계 구역으로 설정하고 누가 올라타면 자물쇠를 걸어 잠근다. 그리고 작업이 끝나면 잠금을 해제하는 방식으로 구현한다.

# 임계 구역(ciritical section)
공유를 해서는 안되는 자원 또는 코드 영억을 뜻한다.

# 바이트 순서(Byte Order)
컴퓨터 아키텍처 및 프로그래밍 언어 간의 데이터 저장 및 표현 방식을 나타내는 중요한 개념이다. 바이트 순서는 CPU가 정수 값을 메모리에 저장할 때 바이트들의 순서를 나타낸다. 이 바이트 순서에는 크게 두 가지가 있다.

|       |         Big-Endian          |        Little-Endian        |
| :---: | :-------------------------: | :-------------------------: |
| 방식  | MSB(Most Siginificant Byte) | LSB(Least Significant Byte) |
|       |   데이터를 순서대로 기록    |    데이터를 역으로 기록     |
| 장점  |        디버깅이 쉬움        |       디버깅이 불편함       |
|       |       산술연산이 느림       |       산술연산이 빠름       |
|       |       비교연산이 빠름       |       비교연산이 느림       |
|       |     타입 변환이 어려움      |      타입 변환에 유리       |
| 예시  |        리눅스(서버)         |           윈도우            |
|       |         안드로이드          |           아이폰            |
|       |   서버(네트워크 프로토콜)   |         클라이언트          |

네트워크 통신에서 데이터 교환을 할 때 서버와 클라이언트 간의 엔디언을 맞추는 것이 중요하다.

# 문자 집합(Character Set)
글자와 기호들의 모음이다. 각 문자는 컴퓨터에서 이해할 수 있는 코드로 매칭된다.

> ASCII(American Standard Code for Information Interchange)
>
> 초기 컴퓨터와 통신 장치 간에 문자를 표현하는 데 사용되는 표준 문자 집합이다. 알파벳, 숫자, 특수 문자, 제어 문자, 공백 문자를 1바이트로 표현한다. 0부터 127까지 총 128개의 문자를 나타낸다.

> UNICODE(Universal Coded Character Set)
>
> 컴퓨터 시스템 및 소프트웨어 간에 서로 다른 문자 인코딩 체계로 인한 호환성 문제를 해결하기 위해 개발된 표준 문자 집합이다. 다양한 언어와 문자를 표현할 수 있다. `U+` 기호를 접두어로 사용한다. 최초에는 2바이트로 문자를 표현했지만 점차 다양한 문자와 심볼의 필요성이 증가함에 따라 U+0000부터 U+10FFFF까지 확장되었습니다.

# 인코딩(Encoding)
문자 집합은 문자를 숫자로 매핑하므로 문자를 컴퓨터에서 사용 가능한 숫자로 변환하거나 그 반대로 변핸하는 과정이 필요하다. 이런 프로세스를 인코딩과 디코딩이라고 부르며 컴퓨터와 사람 사이에서 텍스트를 효과적으로 처리하고 표현하기 위해 필요하다. 아래는 우리나라에서 아직도 자주 쓰는 구식 인코딩/디코딩 방식들이다.

> EUC-KR
>
> 주로 유닉스 및 리눅스 기반 시스템에서 한국어를 포함한 다양한 언어를 표현하기 위한 문자 인코딩 방식 중 하나다. 완성형 문자 인코딩 방식으로 각 한글 문자는 2바이트로 표현된다.

> CodePage 949
>
>  마이크로소프트가 도입한 문자 인코딩 방식으로 한글 및 영문 등 다양한 문자를 지원한다. 완성형 문자 인코딩 방식으로 DOS 및 일부 구식 윈도우 시스템에서 사용되며 EUC-KR의 상위 호환으로 취급된다.

# UTF(Unicode Transformation Format)
유니코드 문자를 컴퓨터에서 저장하고 표현하기 위한 표준화된 방식이다. UTF는 유니코드 표준을 실제로 사용 가능한 이진 데이터로 변환하는 역할을 한다. 이를 통해 다양한 문자와 기호를 효과적으로 표현하고 다국어 환경에서 텍스트를 교환하고 저장할 수 있다.

> UTF-8(Universal Coded Character Set Transformation Format - 8 bit)
>
> 가변 너비 인코딩 방식으로 대부분의 현대 시스템에서 사용한다. 이 형식은 ASCII 문자를 1바이트로 표현하고 유니코드 문자 하나는 1바이트에서 4바이트로 효과적으로 인코딩한다.

> UTF-16
>
> 기본적으로 다국어 문자를 16비트로 표현하며 이를 초과하는 범위에 해당하는 문자는 32비트로 인코딩한다. 한글과 같은 대부분의 문자가 2바이트로 표현되는 UTF-16은 메모리 공간 측면에서 상당히 효율적이다. 그러나 UTF-8과 비교하면 메모리 사용 측면에서 일부 단점이 있을 수 있다.

> UTF-32
>
> 고정 너비 인코딩 방식으로 모든 유니코드 문자를 그대로 저장하고 32비트로 표현한다. 모든 문자를 일관된 크기로 저장한다는 장점이 있으며 UTF-32로 인코딩된 텍스트는 모든 문자에 대한 직접적인 표현을 제공한다.

위에서 보았듯이 UTF-8 및 UTF-16과 같은 유니코드 인코딩 방식은 가변 너비 인코딩의 좋은 예이다. 각 문자는 필요에 따라 다른 수의 바이트로 효율적으로 인코딩된다. 이는 다양한 언어와 문자를 효과적으로 표현하고 저장하는 데 사용된다. 유니코드가 아닌 방식에는 크게 DBCS와 MBCS가 있으나 유니코드와 비교하여 불편한 점이 많은 편이다.

UTF-16과 UTF-32 인코딩 방식은 각각 2바이트와 4바이트로 문자를 저장하므로 엔디만 문제를 일으킬 수 있다. 데이터가 엔디안 방식과 호환되지 않으면 잘못된 데이터 해석이 발생할 수 있다. 따라서 엔디안 문제와 무관하게 사용 가능한 UTF-8이 거의 표준으로 자리잡았다.

# 랜덤
컴퓨터는 엄밀하게는 난수를 생성할 수가 없다. 따라서 편법을 써서 최대한 그럴듯하게 만드는 수밖에 없다.

```
#include <iostream>

int main() {
	srand(time(nullptr));

	std::cout << "--- 0 ~ 5 ---" << std::endl;
	for (int i = 0; i < 10; i++) {
		std::cout << rand() % 5 << std::endl;
	}
	
	std::cout << "--- 5 ~ 12 ---" << std::endl;
	for (int i = 0; i < 10; i++) {
		std::cout << rand() % 8 + 5 << std::endl;
	}
	// 공식 : rand % (end - start + 1) + start
}
```

C++에 들어서는 조금 더 고급화된 알고리즘을 사용한다. 아래는 메르센 트위스터 19937 랜덤 알고리즘을 사용한 클래스다.

```
#include <iostream>
#include <random>
#include <vector>

int main() {
	std::random_device rd;
	std::mt19937 rand(rd());

	for (int i = 0; i < 10; i++) {
		std::cout << rand() % 10 << "\t";
	}
	std::cout << std::endl;

	// 분포 제어 가능
	std::uniform_int_distribution<> dist(0, 9);
	for (int i = 0; i < 10; i++) {
		std::cout << dist(rand) << "\t";
	}

	// 셔플 기능
	std::vector<int> deck{ 1,2,3,4,5,6,7,8,9,10 };
	for (int i = 0; i < deck.size() * 2; i++) {
		int i1 = dist(rand);
		int i2 = dist(rand);
		std::swap(deck[i1], deck[i2]);
	}
	std::cout << std::endl;
	for (auto e : deck) {
		std::cout << e << "\t";
	}

	// 셔플 알고리즘 있음
	std::shuffle(deck.begin(), deck.end(), rand);
	std::cout << std::endl;
	for (auto e : deck) {
		std::cout << e << "\t";
	}
}
```

# 설계 방식
프로그램을 개발할 때는 크게 두 가지 방식이 있다. 먼저, 하향식 설계(Top-Down Design)는 전체 구조를 설계하고 세부 사항을 구체화하는 방식이다. 사전 작업이 조금 걸리지만 그만큼 코딩에 들어가는 시간이 적어진다. 전체가 구현되기 전까지는 테스트가 힘들다는 단점이 있다. 그리고 상향식 설계(Bottom-Up Design)는 작은 기능을 먼저 구현한 후 시스템으로 조립하는 방식이다. 코딩과 테스트에 집중하는 만큼 시간이 오래 걸린다. 단위 테스트를 자동화할 수 있다면 매우 안정적이고 효율적이다. 그렇지 않다면 개발 시간이 걸린다.

# 캐시
임시 저장소다. 어떤 데이터를 램에서 꺼내올 때 일단은 캐시에 저장한다. 나중에 동일한 데이터 혹은 인접한 데이터를 꺼낼 일이 있으면 CPU가 자기가 들고 있는 캐시 메모리를 먼저 확인하고 찾다 찾다 없으면 램으로 가는 방식이다.

캐시 철학에는 두 가지가 있다. 먼저, Temporal Locality는 시간적으로 분석해보면 가장 최근에 사용한 변수같은 것이 다시 사용될 확률이 높다고 가정하는 접근법이다. 그리고 Speical Locality는 공간적으로 분석해보면 가장 최근에 사용한 변수같은 것의 주소 근처에서 다시 사용될 확률이 높다고 가정하는 접근법이다.

# CPU 파이프라인
빨래를 하고, 건조기에 넣어 건조하고, 다림질을 하고, 옷을 개빈다. 마냥 기다리는 것이 아니라 빨래가 여러 바구니라면 세탁기가 비면 다음 빨래를 넣고, 뒤에 있던 빨래가 건조되었다면 먼저 옷을 개비는 것이 효율적이다. 이런 상황이 CPU에서도 똑같이 벌어진다. 

CPU도 여러 단계에 걸친 CPU 파이프라인이 있다. 따라서 더 효율적이도록 요청의 순서를 바꾸기도 하는 것이다.

# SIMD(Single Instruction Multiple Data)
하나의 명령어로 여러 개의 데이터를 동시에 처리하는 기술로 대표적으로 SSE, SSE2, 그리고 최근에는 AVX가 널리 사용된다. 이를 활용하면 멀티미디어 데이터 처리와 같은 대규모 데이터에서 효율적으로 연산을 수행할 수 있다.

Microsoft에서는 SIMD를 지원하기 위해 새로운 데이터 타입인 __m128를 선언하였고, 이는 DirectXMath에서 사용된다. 이 데이터 타입은 128비트 SIMD 연산에 최적화된 형식으로 CPU 레지스터와 직접 대응된다.

# 호출 규칙
함수 호출 시에는 매개변수 전달과 반환 값을 처리하기 위한 호출 규칙이 있다. 예를 들어, __cdecl은 C/C++ 표준으로 매개변수를 스택에 역순으로 저장하고, __fastcall는 레지스터를 활용하여 인수를 저장하며 스택에 남은 것들을 역순으로 push한다. 이렇게 하는 것은 레지스터를 사용하여 연산을 빠르게 처리하기 위함이다. DirectXMath에서는 플랫폼에 따라 자동으로 적절한 호출 규칙을 선택하여 최적의 성능을 제공한다.

# Register Type vs Memory Type
빠른 연산을 위해 SIMD를 사용할 때 데이터를 효과적으로 관리하기 위한 새로운 데이터 타입이 필요하다. XMVECTOR는 SIMD에 대응하는 128비트 레지스터에 저장되는 형식으로 빠른 계산을 가능케 한다. 그러나, 힙에서는 메모리 정렬의 문제로 인해 좀 더 주의가 필요하다. 이런 경우, XMVECTOR를 세분화하여 XMFLOAT과 같은 메모리 형식을 사용하여 플랫폼 독립적인 코드를 유지하면서도 안전하게 데이터를 다룰 수 있다.