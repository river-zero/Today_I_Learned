- [트리](#트리)
- [이진 트리(Binary Tree)](#이진-트리binary-tree)
- [트리 순회(Tree Traversal)](#트리-순회tree-traversal)
- [너비 우선 탐색(Breadth-First Search, BFS)](#너비-우선-탐색breadth-first-search-bfs)
- [깊이 우선 탐색(Depth First Search, DFS)](#깊이-우선-탐색depth-first-search-dfs)
- [이진 탐색 트리(Binary Search Tree, BST)](#이진-탐색-트리binary-search-tree-bst)
- [쿼드 트리(Quad Tree)](#쿼드-트리quad-tree)
- [힙(Heap)](#힙heap)
- [힙 정렬(Heap Sort)](#힙-정렬heap-sort)

# 트리
게임에서 사용하는 스킬 트리나 마인드맵과 같이 나무에서 나뭇가지가 뻗어져 나가는 형태를 가져 데이터를 계층적으로 표현하는 자료구조다. 트리는 여러 노드(Node)와 간선(Edge)로 이루어져 있으며 아래와 같은 특성을 가지고 있다.

> 루트 노드(Root Node)
>
> 트리의 시작점으로 다른 모든 노드와 연결되어 있다. 부모가 없는 유일한 노드로 나무의 뿌리와 같다. 

> 리프 노드(Leaf Node)
>
> 트리의 끝단에 위치한 노드로 자식 노드를 가지고 있지 않다. 나뭇잎에 해당한다고 볼 수 있다.

> 내부 노드(Internal Node)
>
> 리프 노드가 아닌 모든 노드를 내부 노드라고 한다. 즉, 부모와 자식을 가지는 노드다. 

> 자식(Child)과 부모(Parent)
>
> 트리에서 노드들은 서로 연결되어 있으며 한 노드의 바로 아래에 연결된 노드를 자식 노드, 역으로 상위 노드를 부모 노드라고 부른다.

> 형제(Sibling)
>
> 같은 부모를 가진 노드들을 형제라고 부른다. 이들은 동일한 레벨에 위치한다.

> 레벨(Level)
>
> 동일한 깊이(Depth)를 가지는 노드들의 집합이다. 루트 노드는 레벨 0에 위치하며 아래로 내려갈수록 레벨이 증가한다.

> 깊이(Depth)
>
> 트리의 최고 레벨을 나타낸다. 트리의 높이(Height)라고도 한다. 루트 노드에서 어떤 노드까지의 경로를 따라 내려갔을 때 몇 번의 간선을 거치는지를 나타내는 개념이다. 이때, 한 노드에서 다른 노드로 가는 경로는 유일하게 존재해야 한다.

# 이진 트리(Binary Tree)
트리의 하위 개념으로 각 노드가 최대 두 개의 자식 노드를 가지는 트리 구조다. 컴퓨터 자료구조에서 대부분의 트리는 바로 이진 트리를 일컫는다. 일반적으로 다음과 같은 세 가지 주요 형태로 나눌 수 있다.

> Full Binary Tree
>
> 리프 노드를 제외한 모든 노드가 두 개의 자식으로 채워져 있다.

> Perfect Binary Tree
>
> Full Binary Tree의 특별한 형태로 마지막 레벨까지 두 개의 자식으로 꽉 채워져 있다.

> Complete Binary Tree
>
> 마지막 레벨을 제외하고는 모든 레벨에 노드가 들어 있고 리프 노드가 추가될 때는 왼쪽부터 채워진다.

# 트리 순회(Tree Traversal)
트리 구조에서 노드를 효과적으로 방문하는 방법을 나타낸다. 트리의 각 노드를 방문하면서 특정 작업을 수행하거나 데이터를 검색하는 데 사용된다. 크게 너비 우선 탐색(Breadth First Search)와 깊이 우선 탐색(Depth First Search)로 나눌 수 있다.

# 너비 우선 탐색(Breadth-First Search, BFS)
트리를 가로로 탐색하는 방법으로 같은 레벨의 노드를 먼저 탐색한다. 이 방법은 일반적으로 큐를 사용해 구현한다. 레벨 순서대로 노드를 방문하고 자식 노드를 큐에 추가하는 방식이다. 이때, 루트 노드부터 시작해 왼쪽에서 오른쪽으로 이동하면서 레벨을 내려간다. 같은 레벨의 노드를 먼저 방문하므로 최단 경로를 찾는 데 유용하다.

시간 복잡도는 최악의 경우 모든 노드를 방문해야 하므로 O(n)이다. 공간 복잡도는 가장 밑바닥 레벨에 있는 노드까지 큐에 저장되므로 최악의 경우 O(n)이다. 완전 이진 트리와 같이 균형잡힌 트리의 경우에는 O(log n)까지 빨라질 수도 있다.

# 깊이 우선 탐색(Depth First Search, DFS)
트리를 세로로 탐색하는 방법으로 한 가지 노드의 자식들을 모두 방문한 후에 해당 노드로부터 다른 자식 노드로 이동하는 방식이다. 주로 스택과 재귀 함수를 활용해 구현한다. 깊이 우선 탐색은 다음과 같은 세 가지 주요 방법으로 나눌 수 있다.

> 전위 순회(Preorder Traversal)
>
> 현재 노드를 먼저 방문한 후에 왼쪽 서브 트리를 순회하고 오른쪽 서브 트리를 순회한다.

> 중위 순회(Inorder Traversal)
>
> 왼쪽 서브 트리를 먼저 순회한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브 트리를 순회한다.

> 후위 순회(Postorder Traversal)
>
> 왼쪽 서브 트리와 오른쪽 서브 트리를 모두 순회한 후 현재 노드를 방문한다.

시간 복잡도는 마찬가지로 O(n)이다. 공간 복잡도는 재귀 함수를 사용하는 경우 호출 스택의 깊이에 따라 결정된다. 최악의 경우 스택의 깊이가 트리의 높이와 같아지므로 O(n)이고, 최선의 경우에는 O(log n)까지 줄어들 수 있다.

# 이진 탐색 트리(Binary Search Tree, BST)
이름에서 알 수 있듯이 어떠한 값을 찾는 데에 특화된 트리다. 이진 탐색 트리의 핵심은 왼쪽 자식 노드는 나보다 작고 오른쪽 자식 노드는 나보다 크다는 것이다. 다양한 알고리즘과 자료 구조의 기초로 사용되는 중요한 자료 구조 중 하나다.

- 트리 내부의 모든 노드는 정렬된 상태를 유지한다.
- 이진 트리의 특성을 가진다.
- 왼쪽 서브 트리는 루트 노드보다 작다.
- 오른쪽 서브 트리는 루트 노드보다 크다.
- 모든 서브 트리는 이진 탐색 트리의 특성을 만족한다.
- 중위 순회를 하게 되면 오른차순으로 정렬된 결과를 얻을 수 있다.
- 그래프 ⊃ 트리 ⊃ 이진 트리 ⊃ 이진 탐색 트리의 포함 관계를 가진다.

루트 노드부터 시작해 탐색 대상과 비교하여 왼쪽 또는 오른쪽 자식 노드로 이동하면서 검색을 수행하는 방식으로 검색 시간 복잡도가 평균적으로 O(log n)이다. 불균형한 트리가 형성될 경우 O(n)까지 걸릴 수 있다. 빠르지만 트리를 구축하는 데에는 시간이 걸리는 편이다.

균형 이진 탐색 트리의 일종으로는 레드-블랙 트리가 있다. std::set이 바로 이 레드-블랙 트리를 내부적으로 사용하여 데이터를 관리하고 정렬된 상태를 유지한다. 

# 쿼드 트리(Quad Tree)
네 개의 자식을 가지는 트리로 공간을 효과적으로 분할하고 관리하기 위해 사용하는 자료구조 중 하나다. 주로 2차원 공간을 다루는 데 사용하며 이미지 압축, 오버레이, 공간 분할 등에 다양하게 활용된다.

쿼드 트리의 핵심은 공간을 4개의 사분면으로 균등하게 분할하는 것이다. 이러한 분할은 재귀적으로 이루어진다.

시간 복잡도의 경우 탐색 및 삽입 작업은 공간의 크기에 따라 다르다. 보통 로그 시간이 걸린다. 공간을 4개의 사분면으로 나누어 탐색하기 때문에 시간 복잡도는 O(log n)이다. 공간 복잡도의 경우 쿼드 트리의 공간 사용량은 얼마나 많은 포인트를 나누느냐에 따라 결정된다. 기본적으로는 로그식이지만 각 픽셀마다 처리가 필요하다. 따라서 픽셀의 수를 k라 하고 전체 크기를 n x n이라고 한다면 공간 복잡도는 O(k log n)이다.

# 힙(Heap)
이는 FIFO 특성을 가지는 힙과는 다른 개념이므로 혼동하지 않도록 주의해야 한다. 주로 Complete Binary Tree 형태로 구현하며 최댓값과 최솟값을 효율적으로 찾는 데에 사용한다. 힙은 일반적으로 최대 힙과 최소 합으로 나눈다. 최대 힙의 경우 부모의 값이 항상 자식들보다 크고, 최소 힙의 경우 부모의 값이 항상 자식들보다 작다.

실제 힙의 구현에는 일반적으로 트리보다는 배열을 사용한다. 트리의 구조와 배열의 인덱스를 잘 생각해보면 아래와 같은 규칙이 만들어진다. 물론 이는 시작 인덱스가 1인 경우에 해당하므로 실제로 힙을 구현할 때에는 약간의 수정이 필요하다.

- 왼쪽 자식의 인덱스 = 부모의 인덱스 * 2
- 오른쪽 자식의 인덱스 = (부모의 인덱스 * 2) + 1
- 부모의 인덱스 = (자식의 인덱스) / 2

삽입의 경우 시간 복잡도는 힙의 성질을 유지하기 위해 부모와 비교해 재배치 작업을 하고 이는 트리의 높이에 비례하므로 O(log n)을 가진다. 공간 복잡도는 힙의 크기에 따라 선형적으로 증가한다. 특별한 변수를 사용하지도 재귀호출을 하지도 않으니 O(n)이다.

삭제의 경우 핵심 아이디어는 루트 노드의 값과 리프 노드의 값을 바꿔치기하는 것이다. 제일 마지막 원소는 지워도 트리의 형태에 영향을 주지 않기 때문이다. 루트 노드를 삭제하고 힙을 재조정하는 작업이 있으므로 시간 복잡도는 힙의 높이에 비례하여 O(log n)이다. 삭제 작업에는 별다른 공간이 더 필요하지 않으므로 공간 복잡도는 O(1)이다.

# 힙 정렬(Heap Sort)
힙에서 루트 노드가 항상 최댓값이나 최솟값을 가지고 있다는 점을 이용하면 정렬 알고리즘으로 사용할 수도 있다. 최대 힙의 경우 내림차순으로, 최소 힙의 경우 오름차순으로 정렬이 되어 나온다.

배열의 크기가 n일 때, 배열을 n번 순회하면서 각 순회마다 log n번의 연산을 수행하므로 힙 정렬 전체의 시간 복잡도는 O(n log n)이다. 추가적인 배열을 사용하지 않고 입력 배열 내에서 정렬을 수행하기 때문에 공간 복잡도는 O(1)이다.

priority_queue는 우선순위 큐로 기본적으로 최대 힙의 동작을 따른다. 큰 숫자가 높은 우선순위를 가지므로 큰 값이 먼저 나오게 되는 것이다. 이런 특성으로 인해 힙 정렬과 관련된 문제를 해결하는 데 효과적인 대안으로 사용될 수 있다.

아래는 C++20에서 추가된 힙과 관련된 기능에 대한 설명이다.

> std::make_heap()
>
> 주어진 범위 [first, end)의 원소들을 힙으로 만든다. 기본적으로 std::less<>를 사용하므로 최대 힙을 만들게 된다.

> std::push_heap()
>
> 힙에 원소를 추가한다. 이때, 컨테이너의 원소들은 힙의 성질을 만족해야 하고 실제로 원소를 추가하는 부분은 컨테이너의 기능을 사용해야 한다. std::push_heap()은 원소를 힙에 추가하는데 필요한 내부 조정 작업만 수행하기 때문이다.

> std::sort_heap()
>
> 힙의 원소들을 정렬한다. 이때, 컨테이너의 원소들은 힙의 성질을 만족해야 한다. 정렬된 결과는 더 이상 힙의 특성을 가지지 않고, 대신 정렬된 배열의 특성을 가지게 된다.