- [Sprite](#sprite)
- [Singleton Pattern](#singleton-pattern)
- [Interpolation](#interpolation)

# Sprite
컴퓨터 그래픽에서 2D 이미지, 특히 독립적으로 따로 움직이는 오브젝트를 스프라이트라고 부른다. 이미지가 배경 이미지 위로 둥둥 떠다니는 모습에 요정이라는 어원에서 따 온 개념이다. 초기 게임기나 컴퓨터들은 이런 스프라이트를 하드웨어로 제어해 빠른 처리를 하려고 노력했다. 어떻게 본다면 하드웨어 가속의 시발점이다. 요즘 게임들은 한 화면에 수천 개의 스프라이트를 그리니까 효율적인 관리가 필수다. 

# Singleton Pattern
디자인 패턴 중 하나로, 딱 한 명의 관리자만을 둔다는 개념이다. 클래스로 예를 들면, 여러 번 생성자가 부리더라도 인스턴스가 하나만 유지되는 형태다. 생성자가 여러 번 호출되어도 실제로 생성되는 객체는 하나이고, 또 다시 생성자가 호출되면 최초 생성 이후에는 이미 생성된 객체를 반환하게 된다.

```
class Singleton final {
public:
    // 이 인스턴스를 통해서만 접근
    static Singleton& Instance() {
        static Singleton instance;
        return instance;
    }

// 다른 곳에서 내부에 접근하지 못하도록 모조리 숨김
private:
    Singleton();                      // 기본 생성자
    Singleton(const Singleton&);      // 복사 생성자
    void operator=(const Singleton&); // 대입 연산자

public:
    ~Singleton();

public:
    void MyFunction();
};
```

과유불급이라고 싱글턴 패턴을 남발하는 것 또한 좋지 않다. 

- 멀티스레드 환경에서 싱글톤을 사용할 때 동시성 문제가 발생할 수 있다.
- 일반적으로 싱글톤은 앱이 종료될 때까지 메모리에 상주한다. 이는 앱의 라이프 사이클 동안 메모리를 점유하게 되어 메모리 누수의 원인이 될 수 있다.
- 테스트하기 어려울 수 있다. 
- 싱글톤이 다른 클래스에 의존하고, 그 클래스가 다시 싱글톤을 참조하는 경우 순환 종속 문제가 발생할 수 있다.
- 상속과 확장이 어려울 수 있다.

모든 곳에서 접근이 필요한 관리자 객체에만 적용하는 것을 추천한다.

# Interpolation
우리가 보는 이미지는 실제로는 모눈정이 찍은 점이다. 따라서 표현하려는 이미지가 정확하게 픽셀의 가운데가 될 수 없는 경우도 존재한다. 이러한 문제를 해결하기 위한 것이 보간(Interpolation)이다. 다음과 같은 방법이 자주 사용된다.

> Nearest-neighbor
>
> 각 픽셀에 대해 가장 가까운 이웃 픽셀의 값을 사용한다. 계산이 간단하고 빠르지만, 결과물이 블록 형태로 극단적인 경우가 발생할 수 있다.

> Linear
>
> 두 가까운 픽셀 사이에 선을 그어 그 중간값을 사용한다. 결과물이 좀 더 부드러워지며, 계산 비용이 적당한다.

> Bilinear
>
> 4개의 가까운 픽셀을 고려하여 각 픽셀의 가중 평균값을 계산한다. 이미지를 더 자연스럽게 보여줄 수 있다.

> Trilinear
>
>  8개의 가까운 픽셀을 고려하여 보간한다. 주로 3D 텍스처 매핑 등에서 사용된다.

> Cubic
>
> 16개의 주변 픽셀을 고려하여 3차 다항식을 사용하여 값을 계산한다. 높은 정확도를 제공하지만 계산 비용이 상대적으로 높다.