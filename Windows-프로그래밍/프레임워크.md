- [Application Framework](#application-framework)
- [Library, API, SDK, Framework](#library-api-sdk-framework)
- [Microsoft::WRL::ComPtr](#microsoftwrlcomptr)
- [Inline Function](#inline-function)
- [WM\_CREATE](#wm_create)
- [Direct2D Resources](#direct2d-resources)
- [Device Lost](#device-lost)

# Application Framework
프레임워크란 건축으로 치면 철골 구조에 해당한다. 따라서 Application Framework란 소프트웨어 응용 프로그램을 개발하는 데 사용되는 기본 구조와 도구의 집합을 말한다. 응용 프로그램을 구축하고 개발하는 데 필요한 핵심 구조, 도구, 라이브러리, 및 관련된 기능들을 제공하여 소프트웨어 개발을 보다 효율적이고 일관되게 만들어준다.

그래픽, 사운드와 같은 복잡한 기능들은 라이브러리나 SDK이 도움을 받고, 기본적인 초기화 해제 작업을 미리 해두면 그게 바로 프레임워크다. 이렇게 프레임워크를 만들어두면 다음에 게임을 제작할 때 훨씬 편해진다.

# Library, API, SDK, Framework
|   요소    |                                                                                                     설명                                                                                                     |
| :-------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|  Library  |                                              미리 작성된 코드 모음으로 쉽게 사용할 수 있도록 정의를 담은 .h 파일이나 컴파일된 라이브러리 .lib 파일 형태로 제공                                               |
|    API    | 애플리케이션 개발을 위해 주로 운영 체제 또는 다른 소프트웨어 컴포넌트에서 필요한 기능을 제공하는 인터페이스로 애플리케이션과 운영 체제, 하드웨어, 또는 다른 서비스 및 라이브러리와의 상호 작용을 용이하게 함 |
|    SDK    |                                                                   응용 프로그램 개발을 위한 도구와 자료의 모음으로 API와 도구를 함께 제공                                                                    |
| Framework |                                                     응용 프로그램을 개발하는 데 사용되는 기본 구조와 도구의 집합으로 개발자에게 미리 정의된 구조를 제공                                                      |

카페에 비유하자면 Library는 메뉴판, API는 주문 창구, SDK는 원두나 그라인더, Framework는 내부 인테리어에 해당한다. 포함관계로 따지면 Library ⊂ API ⊂ SDK ⊂ Framework라고 할 수 있다.

# Microsoft::WRL::ComPtr
C++ 개발자를 위한 COM 객체에 대한 스마트 포인터 클래스다. COM 객체들은 C++ 객체와 생성과 소멸 취급 방법이 다르니 기존의 스마트 포인터를 사용할 수가 없기 때문에 이를 쓴다. 기본적으로는 shared_ptr과 같은 방식으로 COM 객체의 레퍼런스 카운팅을 자동으로 관리해준다. `#include <wrl.h>` 또는 더 가볍게 쓰고 싶다면 `#include <wrl/client.h>`를 포함하면 된다.

일반적으로 COM 객체는 팩토리 또는 헬퍼 함수를 통해 생성되고 매개변수로 인터페이스에 대한 포인터의 주소(**)를 넘겨준다. ComPtr은 이를 GetAddressOf() 메서드로 제공한다. 만약, Comptr 객체를 클래스 멤버로 사용하고 있고 이미 초기화가 되어 있는지 확실하지 않다면 더 안전하게 ReleaseAndGetAddressOf() 메서드를 사용한다. 또, 해제는 자동으로 이뤄지지만 명시적으로 수행하고 싶다면 Reset() 메서드를 사용하면 된다. COM 객체의 포인터가 필요하다면 역시 명시적으로 Get()을 통해 접근하는 것이 좋다.

매개변수로 사용하는 경우에는 주의해야 한다. 그냥 넘겨주면 참조 카운트가 하나 증가하므로 `void func(const Microsoft::WRL::ComPtr<T>& param);` 또는 `void func(T* param);`과 같이 사용한다.

# Inline Function
함수를 개별 호출로 처리하는 것이 아니라 해당 함수를 호출하는 곳에 직접 코드가 삽입된다. #define처럼 말이다. 함수 호출에 필요한 호출 스택에 정보를 넣고 빼는 과정이 없어서 빠르게 처리가 가능하다. 자주 호출되는 함수를 인라인으로 처리하면 해당 함수 코드가 반복해서 삽입되므로 코드의 길이가 증가할 수 있다.

일반 함수는 선언 또는 정의 앞에 inline 키워드를 붙이면 된다. 멤버 함수라면 반드시 헤더 파일에 정의해야 코드를 바로 복사할 수 있다. 

```
// 선언 시에 inline 키워드 사용
inline void Test();

// 또는
void Test();

// 정의 시에 inline 키워드 사용
inline void Test() {
    // 함수 내용
}
```

```
class MyClass {
public:
    // 멤버 함수 선언과 정의
    inline void Func() {
        // 함수 내용
    }
};

// 또는

class MyClass {
public:
    void Func();
};

// 멤버 함수 정의
inline void MyClass::Func() {
    // 함수 내용
}

```

인라인으로 선언해도 컴파일러가 판단하고 거부할 수 있다는 사실을 알아두자.

# WM_CREATE
CreateWindow 또는 CreateWindowEx 함수를 호출할 때 발생한다. 이 메시지를 처리하는 윈도우 프로시저에서는 윈도우 생성 시 필요한 작업들을 수행할 수 있다. 보통은 이 메시지에서 윈도우의 초기 상태를 설정하거나 추가적인 초기화 작업을 수행한다.

# Direct2D Resources
하드웨어 성능을 활용한 그리기 API는 CPU 중심의 리소스들과 CPU에서도 잘 실행되는 그리기 명령들을 가지고 있다. 그 중 일부만 하드웨어 가속을 지원하는데, GPU는 제작사별로 스펙이 다르므로 하드웨어 가속 리소스를 사용하지 못하는 경우도 있기 때문이다. 따라서 GPU 리소스를 사용하고 그렇지 못한다면 CPU 리소스를 사용할 수 있어야 한다.

Direct2D는 이러한 이유로 리소스를 크게 두 가지로 분류한다. ID2D1Factory와 같이 CPU에서 보관되는 장치 독립적인 리소스(Device-Independent Resource)와, ID2D1RenderTarget과 같이 GPU에 보관되는 장치 의존적인 리소스(Device-Dependent Resource)가 있다. 후자는 하드웨어 가속이 사용 가능하다면 GPU의 리소스에 매핑되어 빠르 그리기가 가능하다. 이러한 리소스들은 Factory를 통해 생성 및 제어된다.

# Device Lost
하드웨어 가속 리소스는 빠르고 높은 품질이라는 장점 대신 CPU/RAM에 비해 매우 한정적인 GPU/V-RAM을 사용하다 보니 리소스 부족 현상을 겪게 된다. 단축키로 작업 전환을 하거나, 시스템 윈도우가 만들어질 때, 절전 모드가 작동하거나, 전체화면 모드로 다른 앱이 실행되거나와 같이 그래픽에 민감한 작업을 할 경우 Device Lost가 발생하게 된다. 특히 게임은 엄청난 GPU/V-RAM을 사용하므로 매우 자주 발생한다. 이런 장치 손실이 발생하면 장치 의존적인 리소스는 아무것도 사용할 수 없는 상태가 되기 때문에 기존 리소스들을 모두 해제하고 다시 만들어야 하는 불상사가 벌어질 수 있다.

DirectX 11 이후로 이런 불편함을 해소할 기능이 추가되었다. 가상 그래픽 디바이스 인터페이스라는 개념을 사용해 여러 개의 앱이 하나의 장치를 사용해도 문제가 없도록 개선하여 장치 손실이 거의 발생하지 않는다. 그럼에도, 실제 물리적인 장치와 연결이 끊어지는 경우에는 불가피하게 장치 손실이 발생한다.